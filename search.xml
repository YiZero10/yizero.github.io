<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-享元模式</title>
      <link href="/posts/2031750427/"/>
      <url>/posts/2031750427/</url>
      
        <content type="html"><![CDATA[<h2 id="具体需求">1. 具体需求</h2><p>展示网站项目需求：</p><p>小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求有些不同：</p><p>1）有客户要求以新闻的形式发布</p><p>2）有客户要求以博客的形式发布</p><p>3）有客户希望以微信公众号的形式发布</p><h2 id="传统解决方式">2. 传统解决方式</h2><h3 id="方案">2.1 方案</h3><p>1）直接复制粘贴一份，然后根据客户不同要求定制修改</p><p>2）给每个网站租用一个空间</p><p>3）方案设计示意图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/12-01-11-image-20221201113939068.png" alt="image-20221201113939068" style="zoom:80%;"></p><h3 id="问题分析">2.1 问题分析</h3><p>1） 需要的网站结构<strong>相似度很高</strong>，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费 2）解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源浪费 3） 对于代码来说，由于是一份实例，维护和扩展都更加容易 4） 上面的解决思路就可以使用 <strong>享元模式</strong> 来解决</p><h3 id="享元模式">3. 享元模式</h3><h3 id="基本介绍">3.1 基本介绍</h3><p>1） 享元模式 (Flyweight Pattern）也叫 蝇量模式：运用共享技术有效地支持大量细粒度的对象 2） 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个 3） 享元模式能够<strong>解决重复对象的内存浪费的问题</strong>，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率 4） 享元模式<strong>经典的应用场景</strong>就是<strong>池技术</strong>了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/12-01-11-image-20221201114514553.png" alt="image-20221201114514553" style="zoom:80%;"></p><h3 id="原理及角色说明">3.2 原理及角色说明</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/12-01-11-image-20221201114632413.png" alt="image-20221201114632413" style="zoom:80%;"></p><p>1）FlyWeight 是抽象的享元角色，他是产品的抽象类，同时定义出对象的外部状态和内部状态(后面介绍）的接口或实现 2）ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务 3） UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。 4） FlyWeightFactory 享元工厂类，用于构建一个池容器(集合）， 同时提供从池中获取对象方法</p><h3 id="内部状态和外部状态">3.3 内部状态和外部状态</h3><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是固定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><p>1）享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态 2） 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变（不会改变的） 3） 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态（会改变的）</p><p>4）举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就可以很好的解决对象开销问题</p><h2 id="享元模式解决方式">4. 享元模式解决方式</h2><p>1）要求：使用享元模式完成前面提出的网站外包问题</p><p>2）思路分析</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/12-01-12-image-20221201120432615.png" alt="image-20221201120432615" style="zoom:67%;"></p><p>3）代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlyWeight</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="comment">//user是外部状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteFlyWeight</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享的部分，内部状态</span></span><br><span class="line">    <span class="keyword">private</span> String type = <span class="string">""</span>;<span class="comment">//网站发布的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"网站的发布形式为："</span> + type + <span class="string">" User "</span> + user.getName() + <span class="string">"在使用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//享元工厂，根据需要返回一个website</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//集合，充当池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据类型返回website，如果没有就创建一个新的并放入pool</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSite</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pool.containsKey(type))&#123;</span><br><span class="line">            pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取网站分类的总数(池子中有多少个网站类型)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">websiteCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();</span><br><span class="line">        <span class="comment">//客户要一个以新闻形式发布的网站</span></span><br><span class="line">        WebSite news = factory.getWebSite(<span class="string">"新闻"</span>);</span><br><span class="line">        news.use(<span class="keyword">new</span> User(<span class="string">"tom"</span>));</span><br><span class="line">        <span class="comment">//客户要一个以博客形式发布的网站</span></span><br><span class="line">        WebSite blog1 = factory.getWebSite(<span class="string">"博客"</span>);</span><br><span class="line">        blog1.use(<span class="keyword">new</span> User(<span class="string">"jack"</span>));</span><br><span class="line">        <span class="comment">//客户要一个以博客形式发布的网站</span></span><br><span class="line">        WebSite blog2 = factory.getWebSite(<span class="string">"博客"</span>);</span><br><span class="line">        blog2.use(<span class="keyword">new</span> User(<span class="string">"tim"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"实际上工厂里有多少个网站呢？"</span> + factory.websiteCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式在jdk--integer的应用源码分析">5. 享元模式在JDK- Integer的应用源码分析</h2><p>1）Integer中的享元模式</p><p>2）代码分析+Debug源码+说明</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/12-01-21-image-20221201210552550.png" alt="image-20221201210552550" style="zoom:80%;"></p><p>3）代码说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果 Integer.valueOf(x) x在-128 --- 127 ֱ直接，就是享元模式返回，如果不在</span></span><br><span class="line"><span class="comment">//范围类，则仍然new </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小结:</span></span><br><span class="line"><span class="comment">//1. 在valueOf方法中，先判断值是否在IntegerCache中，如果不在，就创建新的Integer(new), 否则，就直接从缓存池返回</span></span><br><span class="line"><span class="comment">//2. valueOf方法，就使用到享元模式</span></span><br><span class="line"><span class="comment">//3. 如果使用valueOf方法得到一个Integer实例，范围在-128 - 127，执行速度比new快</span></span><br><span class="line">Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">//得到x实例，类型Integer</span></span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到x实例，类型Integer</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span></span><br><span class="line">Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// 大小，true</span></span><br><span class="line">System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">System.out.println(<span class="string">"x1==x2"</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式的注意事项和细节">6. 享元模式的注意事项和细节</h2><p>1）在享元模式这样理解，“享”就表示共享，“元”表示对象 2）系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式 3）用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable 存储 4）享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率 5）享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方 6） 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制 7）享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-外观模式</title>
      <link href="/posts/1868115705/"/>
      <url>/posts/1868115705/</url>
      
        <content type="html"><![CDATA[<h2 id="具体需求">1. 具体需求</h2><p>组建一个家庭影院：</p><p>DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机，要求完成使用家庭影院的功能，其过程为：</p><p>直接用遥控统筹各设备开关：</p><ul><li>开爆米花机</li><li>降下屏幕</li><li>开投影仪</li><li>开音响</li><li>开DVD，选DVD</li><li>拿爆米花</li><li>调暗灯光</li><li>播放</li><li>观影结束后，关掉各种设备</li></ul><h2 id="传统解决方式">2. 传统解决方式</h2><h3 id="类图">2.1 类图</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-30-15-image-20221130155426413.png" alt="image-20221130155426413" style="zoom:80%;"></p><h3 id="问题分析">2.2 问题分析</h3><ol type="1"><li>在ClientTest类的main方法中，创建各个子系统的对象，并直接去调用子系统（对象）相关方法，会造成调用过程混乱，没有清晰的过程。</li><li>不利于在ClientTest类中去维护对子系统的操作</li></ol><h3 id="解决思路">2.3 解决思路</h3><p>定义一个高层接口，给子系统中的一组接口提供一个一致的界面（比如在高层接口提供四个方法ready、play、pause、end），用来访问子系统中的一群接口。</p><p>也就是说：通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关系这个子系统的内部细节——&gt;<strong>外观模式</strong>。</p><h2 id="外观模式">3. 外观模式</h2><h3 id="基本介绍">3.1 基本介绍</h3><p>1）外观模式（Facade），也叫“过程模式”，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>2）外观模式通过定义一个一致的接口，用以<strong>屏蔽内部子系统的细节</strong>，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p><h3 id="原理类图">3.2 原理类图</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-30-16-image-20221130163249678.png" alt="image-20221130163249678" style="zoom:67%;"></p><h3 id="角色分析">3.3 角色分析</h3><p>1）外观类（Facade）：聚合子系统，为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象。</p><p>2）调用者（Client）：外观接口的调用者。</p><p>3）子系统的集合：指模块或者子系统，处理Facade，对象指派的任务，它是功能的实际提供者。</p><h2 id="外观模式解决方式">4. 外观模式解决方式</h2><h3 id="传统方式解决方式说明">4.1 传统方式解决方式说明</h3><p>1）外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在pc上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</p><p>2）外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用</p><p>3）示意图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-30-17-image-20221130171119029.png" alt="image-20221130171119029" style="zoom:67%;"></p><h3 id="外观模式实例">4.2 外观模式实例</h3><p>1）使用外观模式完成家庭影院项目</p><p>2）思路分析和图解（类图）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-30-17-image-20221130172139575.png" alt="image-20221130172139575" style="zoom:67%;"></p><p>3）代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DVDPlayer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用单例模式（饿汉式）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DVDPlayer instance = <span class="keyword">new</span> DVDPlayer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DVD on……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DVD off……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DVD pause……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DVD play……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popcorn</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用单例模式（饿汉式）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Popcorn instance = <span class="keyword">new</span> Popcorn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Popcorn on……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Popcorn off……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Popcorn pop……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Projector</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用单例模式（饿汉式）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Projector instance = <span class="keyword">new</span> Projector();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Projector <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Projector on……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Projector off……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">focus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Projector focus……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Screen、Stereo、ThreatLight……</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//facade类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义各个子系统对象</span></span><br><span class="line">    <span class="keyword">private</span> TheaterLight light;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> Stereo stereo;</span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> Screen screen;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dvdPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        light = TheaterLight.getInstance();</span><br><span class="line">        popcorn = Popcorn.getInstance();</span><br><span class="line">        stereo = Stereo.getInstance();</span><br><span class="line">        projector = Projector.getInstance();</span><br><span class="line">        screen = Screen.getInstance();</span><br><span class="line">        dvdPlayer = DVDPlayer.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作分成四步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        popcorn.on();<span class="comment">//打开爆米花机</span></span><br><span class="line">        popcorn.pop();<span class="comment">//开始炸爆米花</span></span><br><span class="line">        screen.down();<span class="comment">//降下屏幕</span></span><br><span class="line">        projector.on();<span class="comment">//打开投影</span></span><br><span class="line">        stereo.on();<span class="comment">//打开立体声</span></span><br><span class="line">        dvdPlayer.on();<span class="comment">//打开DVD</span></span><br><span class="line">        light.dim();<span class="comment">//灯光调暗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.play();<span class="comment">//播放DVD</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.pause();<span class="comment">//暂停DVD</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        popcorn.off();<span class="comment">//关闭爆米花</span></span><br><span class="line">        light.bright();<span class="comment">//灯光调亮</span></span><br><span class="line">        screen.up();<span class="comment">//收起屏幕</span></span><br><span class="line">        projector.off();<span class="comment">//关闭投影</span></span><br><span class="line">        stereo.off();<span class="comment">//关闭立体声</span></span><br><span class="line">        dvdPlayer.off();<span class="comment">//关闭DVD</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用各个子系统，很繁琐麻烦</span></span><br><span class="line">        <span class="comment">//使用facade统一调用</span></span><br><span class="line">        HomeTheaterFacade facade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">        facade.ready();</span><br><span class="line">        facade.play();</span><br><span class="line">        facade.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式在mybatis框架应用的源码分析">5. 外观模式在MyBatis框架应用的源码分析</h2><p>1）MyBatis中的Configuration去创建MetaObject对象使用到了外观模式</p><p>2）代码分析+Debug源码+示意图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-30-20-image-20221130203322443.png" alt="image-20221130203322443" style="zoom:80%;"></p><p>3）对源码中使用到的外观模式的角色类图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-30-20-image-20221130202112235.png" alt="image-20221130202112235" style="zoom:67%;"></p><h2 id="外观模式的注意事项和细节">6. 外观模式的注意事项和细节</h2><p>1） 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性 2） 外观模式对客户端与子系统的轉合关系 - 解轉，让子系统内部的模块更易维护和扩展 3） 通过合理的使用外观模式，可以帮我们更好的划分访问的层次 4） 当系统需要进行分层设计时，可以考虑使用 Facade 模式 5） 在维护一个遗留的大型系统时，可能这个系统己经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性 6）不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-组合模式</title>
      <link href="/posts/1191195587/"/>
      <url>/posts/1191195587/</url>
      
        <content type="html"><![CDATA[<h2 id="具体需求">1. 具体需求</h2><p>学校院系展示：</p><p>编写程序展示一个学校院系结构：要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院多有个系，如图。</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-12-11-29-12-image-20221129124239245.png" alt="image-20221129124239245" style="zoom:50%;"></p><h2 id="传统解决方式">2. 传统解决方式</h2><p>1）类图（继承关系）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-12-image-20221129124326176.png" alt="image-20221129124326176" style="zoom:50%;"></p><p>2）问题分析</p><ul><li>继承关系，将学院看作是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的</li><li>实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好的实现管理的操作，比如对学院、系的增删改查等</li><li>解决方案：把学校、学院、系都看作是组织结构，他们之间没有继承关系，而是一种树形结构，可以更好的实现管理操作——&gt;<strong>组合模式</strong></li></ul><h2 id="组合模式解决方式">3. 组合模式解决方式</h2><h3 id="基本介绍">3.1 基本介绍</h3><p>1）组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示<strong>“整体-部分”</strong>的层次关系。</p><p>2）组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p><p>3）这种类型的设计模式属于<strong>结构型模式</strong>。</p><p>4）组合模式使得用户<strong>对单个对象和组合对象的访问具有一致性</strong>，即：组合能让客户以一致的方式处理个别对象以及组合对象。</p><h3 id="原理及角色">3.2 原理及角色</h3><p>1）类图</p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-12-image-20221129125038437.png" alt><figcaption>image-20221129125038437</figcaption></figure><p>2）角色及职责</p><ul><li><strong>Component</strong>：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component子部件（子类），Component可以是抽象类或者接口。</li><li><strong>Leaf</strong>：在组合中表示叶子节点，叶子节点没有子节点（被管理）</li><li><strong>Composite</strong>：非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加（add）、删除……（管理者）</li></ul><p>3）组合模式解决的问题</p><ul><li><p>组合模式解决这样的问题，当我们要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子节点进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子</p></li><li><p>示意图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-12-image-20221129125925881.png" alt="image-20221129125925881" style="zoom:50%;"></p></li></ul><h3 id="应用实例">3.3 应用实例</h3><p>用组合模式实现学校院系展示</p><p>1）思路分析</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-14-image-20221129142011409.png" alt="image-20221129142011409" style="zoom:50%;"></p><p>2）代码示例</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String des;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent component)</span></span>&#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="comment">//为什么不写成抽象？因为有一些子类不需要实现所有方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent component)</span></span>&#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="comment">//为什么不写成抽象？因为有一些子类不需要实现所有方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学校，非叶子节点Composite，可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span></span>&#123;</span><br><span class="line">    List&lt;OrganizationComponent&gt; colleges = <span class="keyword">new</span> LinkedList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, des);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写add方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleges.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleges.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//output学校里面包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span> + getName() + <span class="string">"-----------"</span>);</span><br><span class="line">        <span class="comment">//遍历list</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent college:colleges) &#123;</span><br><span class="line">            college.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学院，非叶子节点Composite</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span></span>&#123;</span><br><span class="line">    List&lt;OrganizationComponent&gt; departments = <span class="keyword">new</span> LinkedList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写add方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.departments.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.departments.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------"</span> + getName() + <span class="string">"--------"</span>);</span><br><span class="line">        <span class="comment">//遍历list</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent department:departments) &#123;</span><br><span class="line">            department.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系，叶子节点，Leaf</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要重写add，remove，因为这是叶子节点，无需管理其他东西</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"清华大学"</span>,<span class="string">"This is a university"</span>);</span><br><span class="line"></span><br><span class="line">        OrganizationComponent csCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>,<span class="string">"计算机学院"</span>);</span><br><span class="line">        OrganizationComponent ieCollege = <span class="keyword">new</span> College(<span class="string">"信息与通信工程学院"</span>,<span class="string">"信息与通信工程学院"</span>);</span><br><span class="line"></span><br><span class="line">        university.add(csCollege);</span><br><span class="line">        university.add(ieCollege);</span><br><span class="line"></span><br><span class="line">        csCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机科学与技术"</span>,<span class="string">"计算机科学与技术"</span>));</span><br><span class="line">        csCollege.add(<span class="keyword">new</span> Department(<span class="string">"信息安全"</span>,<span class="string">"信息安全"</span>));</span><br><span class="line">        csCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程"</span>,<span class="string">"软件工程"</span>));</span><br><span class="line"></span><br><span class="line">        ieCollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程"</span>,<span class="string">"通信工程"</span>));</span><br><span class="line">        ieCollege.add(<span class="keyword">new</span> Department(<span class="string">"网络工程"</span>,<span class="string">"网络工程"</span>));</span><br><span class="line"></span><br><span class="line">        university.print();</span><br><span class="line">        System.out.println(<span class="string">"show cs college"</span>);<span class="comment">//可以分隔开打印</span></span><br><span class="line">        csCollege.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式在jdk集合的源码分析">4. 组合模式在JDK集合的源码分析</h2><p>1）Java的集合类-HashMap就使用了组合模式</p><p>做了两层Component：Map是一个接口，有put、putAll等方法，而AbstractMap是一个抽象类默认实现Map的方法，</p><p>HashMap是非叶子节点Composite，重写了方法</p><p>HashMap类中的内部类Node就是叶子节点</p><p>2）代码分析+Debug源码</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-14-image-20221129145415082.png" alt="image-20221129145415082" style="zoom:80%;"></p><p>3）类图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-29-14-image-20221129145807909.png" alt="image-20221129145807909" style="zoom:67%;"></p><h2 id="组合模式的注意事项和细节">5. 组合模式的注意事项和细节</h2><p>1）简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。 2） 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动(OCP原则) 3） 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构 4） 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式 5） 要求较高的抽象性，如果<strong>节点和叶子有很多差异性</strong>的话，比如很多方法和属性都不一样，不适合使用组合模式</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰者模式</title>
      <link href="/posts/1942064508/"/>
      <url>/posts/1942064508/</url>
      
        <content type="html"><![CDATA[<h2 id="具体需求">1. 具体需求</h2><p>星巴克咖啡订单项目（咖啡馆）：</p><p>1）咖啡种类/单品咖啡：Espresso（意大利浓咖啡）、ShortBlack、LongBlack（美式咖啡）、Decaf（无因咖啡）</p><p>2）调料：Milk、Soy（豆浆）、Chocolate</p><p>3）要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</p><p>4）使用OO的来计算不同种类咖啡的费用：客户可以单点咖啡+调料组合（美式+2份Chocolate）</p><h2 id="解决方案1">2. 解决方案1</h2><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-28-20-image-20221128201500855.png" alt="image-20221128201500855" style="zoom:67%;"></p><p>问题分析：</p><p>1）Drink是一个抽象类，表示饮料</p><p>2）des就是对咖啡的描述，比如咖啡的名字</p><p>3）cost()方法就是计算费用，Drink类中做成一个抽象方法</p><p>4）Decaf就是单品咖啡，继承Drink，并实现cost，其他的单品一次类推</p><p>5）Express&amp;&amp;Milk就是单品咖啡+调料，这个组合很多</p><p>6）问题：这样设计，就会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现<strong>类爆炸</strong>。</p><h2 id="解决方案2">3. 解决方案2</h2><p>1）前面分析到方案1因为单品咖啡+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink类，这样就不会造成类数量过多，从而提高项目的维护性（如图）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-28-20-image-20221128201852231.png" alt="image-20221128201852231" style="zoom:80%;"></p><ul><li>说明：milk、soy、chocolate可以设计为Boolean，表示是否要添加相应的调料</li></ul><p>2）问题分析</p><ul><li>方案2可以控制类的数量，不至于造成很多的类</li><li>在增加或删除调料种类时，修改的地方多，代码的维护量很大</li><li>考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应数量int</li><li>考虑使用<strong>装饰者模式</strong></li></ul><h2 id="装饰者模式">4. 装饰者模式</h2><h3 id="基本介绍">4.1 基本介绍</h3><p>1）装饰者模式：<strong>动态的将新功能附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)。 2） 这里提到的动态的将新功能附加到对象和ocp 原则，在后面的应用实例上会以代码的形式体现，请注意体会。</p><h3 id="原理">4.2 原理</h3><p>装饰者模式就像打包一个快递 主体：比如：陶瓷、衣服(Component)//被装饰者 包装：比如：报纸填充、塑料泡沫、纸板、木板//Decorator装饰者 1）Component： 主体，比如类似前面的 Drink 2）ConcreteComponent：具体的主体，比如前面的各个单品咖啡 3）Decorator：装饰者，比如各调料 在如图的 Component 与 ConereteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象成一个类。</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-28-20-image-20221128202831429.png" alt="image-20221128202831429" style="zoom:80%;"></p><h2 id="装饰者模式解决方案">5. 装饰者模式解决方案</h2><ol type="1"><li>设计方案</li></ol><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-28-20-image-20221128203239042.png" alt="image-20221128203239042" style="zoom:80%;"></p><p>说明：</p><ul><li>Drink类就是前面说的抽象类，Component</li><li>Coffee缓冲类，继承了Drink</li><li>ShortBlack就是单品咖啡，ConcreteComponent，继承Component</li><li>Decorator是一个装饰类，含有一个被装饰的对象（Drink obj）</li><li>Decorator的cost方法，进行一个费用的叠加计算，递归的计算价格</li><li>Chocolate就是一个具体的装饰类，装饰者，继承Decorator，重写cost方法</li></ul><ol start="2" type="1"><li><p>装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-28-20-image-20221128203621884.png" alt="image-20221128203621884" style="zoom:50%;"></p><p>说明：</p><ul><li>Milk包含了LongBlack</li><li>一份Chocolate包含了（Milk+LongBlack）</li><li>一份Chocolate包含了（Chocolate+Milk+LongBlack）</li><li>这样不管是什么形式的单品咖啡+调料组合，通过递归方式（包裹再包裹）可以方便的组合和维护</li></ul></li><li><p>代码示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算费用的抽象方法</span></span><br><span class="line">    <span class="comment">//由子类来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Component和ConcreteComponent之间的缓冲类</span></span><br><span class="line"><span class="comment">//将ConcreteComponent共同的部分抽出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"意大利咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">6.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ConcreteComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"美式咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">5.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ConcreteComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"short black"</span>);</span><br><span class="line">        setPrice(<span class="number">4.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ConcreteComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decaf</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setDes(<span class="string">"无因咖啡"</span>);</span><br><span class="line">        setPrice(<span class="number">8.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Decorator</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink obj;<span class="comment">//被装饰者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自己的价格+饮料的价格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDes() + <span class="string">" "</span> + <span class="keyword">super</span>.getPrice() + <span class="string">" &amp;&amp; "</span> + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteDecorator</span></span><br><span class="line"><span class="comment">//具体的Decorator，这里就是调味品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">"巧克力"</span>);</span><br><span class="line">        setPrice(<span class="number">3.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">"牛奶"</span>);</span><br><span class="line">        setPrice(<span class="number">2.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">"豆浆"</span>);</span><br><span class="line">        setPrice(<span class="number">1.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 点一份LongBlack</span></span><br><span class="line">        Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">        System.out.print(<span class="string">"fee1: "</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">" des1: "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 加一份牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> Milk(order);</span><br><span class="line">        System.out.print(<span class="string">"fee2: "</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">" des2: "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 加一份巧克力</span></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        System.out.print(<span class="string">"fee3: "</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">" des3: "</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 加一份巧克力</span></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        System.out.print(<span class="string">"fee4: "</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">" des4: "</span> + order.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式在jdk应用的源码分析">6. 装饰者模式在JDK应用的源码分析</h2><p>Java的IO结构，FilterInputStream就是一个装饰者</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-28-21-image-20221128210920607.png" alt="image-20221128210920607" style="zoom:80%;"></p><ul><li>InputStream是一个抽象类，Component，类比Drink</li><li>FileInputStream、StringBufferInputStream、ByteArrayInputStream……是InputStream的子类，是具体的Component，类比Decaf</li><li>FilterInputStream是InputStream的另一个子类，是一个装饰者Decorator，里面有一个InputStream</li><li>BufferInputStream、DataInputStream、LineNumberInputStream是具体的Decorator</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/posts/554442395/"/>
      <url>/posts/554442395/</url>
      
        <content type="html"><![CDATA[<h2 id="现实生活中的适配器例子">1. 现实生活中的适配器例子</h2><p>泰国插座使用的是两圆孔（欧标），可以买个多功能转换插头（适配器），这样就可以使用了。</p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-14-image-20221127142902707.png" alt><figcaption>image-20221127142902707</figcaption></figure><h2 id="基本介绍">2. 基本介绍</h2><p>1）适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器（Wrapper）。</p><p>2）适配器模式属于结构型模式</p><p>3）主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p><h2 id="工作原理">3. 工作原理</h2><p>1）适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</p><p>2）从用户的角度看不到被适配者，是解耦的</p><p>3）用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p><p>4）用户收到反馈结果，感觉只是和目标接口交互</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-14-image-20221127143648113.png" alt="image-20221127143648113" style="zoom:67%;"></p><h2 id="类适配器模式">4. 类适配器模式</h2><h3 id="类适配器模式介绍">4.1 类适配器模式介绍</h3><p>基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src-&gt;dst的适配</p><h3 id="类适配器模式应用实例">4.2 类适配器模式应用实例</h3><p>1）引用示例说明</p><p>以生活中充电器为例，充电器本身相当于适配器Adapter，220V交流电相当于src（被适配者），我们的dst（目标）是5V直流电</p><p>2）思路分析</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-14-image-20221127145528512.png" alt="image-20221127145528512" style="zoom:67%;"></p><p>3）代码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出220V的电压</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"电压="</span> + src);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = output220V(); <span class="comment">//获取到原来的220V电压</span></span><br><span class="line">        <span class="keyword">int</span> dst = src / <span class="number">44</span>; <span class="comment">//转成5V</span></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(Voltage5V voltage5V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (voltage5V.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"电压是5V，可以充电！"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"电压不对，无法充电！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class Adapter"</span>);</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类适配器模式注意事项和细节">4.3 类适配器模式注意事项和细节</h3><p>1） Java 是单继承机制，所以类适配器需要<strong>继承</strong> src 类这一点算是一个缺点，因为这要求 dst 必须是接口，有一定局限性 2）src 类的方法在 Adapter 中都会暴露出来（Adapter中调用了父类src的方法），也增加了使用的成本。 3）由于其继承了src 类，所以它可以根据需求重写 src类的方法，使得 Adapter 的灵活性增强了</p><h2 id="对象适配器模式">5. 对象适配器模式</h2><h3 id="对象适配器模式介绍">5.1 对象适配器模式介绍</h3><p>1）基本思路和类适配器模式相同，只是将Adapter类作了修改，不是继承src类，而是<strong>持有src类的实例</strong>，以解决兼容性问题。即：持有src类，实现dst接口，完成src-&gt;dst的适配</p><p>2）根据<strong>“合成复用”原则</strong>，在系统中尽量使用<strong>关联关系（聚合）</strong>来替代继承关系</p><p>3）对象适配器模式是适配器模式常用的一种</p><h3 id="对象适配器模式应用实例">5.3 对象适配器模式应用实例</h3><p>1）应用实例说明</p><p>以生活中充电器为例，充电器本身相当于适配器Adapter，220V交流电相当于src（被适配者），我们的dst（目标）是5V直流电，使用对象适配器模式</p><p>2）思路分析：只需修改适配器即可，聚合被适配类</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-15-image-20221127150118330.png" alt="image-20221127150118330" style="zoom:67%;"></p><p>3）代码实现</p><ul><li><p>被适配的类和适配接口不需要改变</p></li><li><p>改变适配器类（Adapter类）</p></li><li><p>使用的类（phone）无需变化</p></li><li><p>客户端需要变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">//关联关系-》聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器传入一个voltage220V实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageObjectAdapter</span><span class="params">(Voltage220V voltage220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != voltage220V)&#123;</span><br><span class="line">            <span class="keyword">int</span> src = voltage220V.output220V(); <span class="comment">//获取到原来的220V电压</span></span><br><span class="line">            dst = src / <span class="number">44</span>; <span class="comment">//转成5V</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Objet Adapter"</span>);</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone1.charging(<span class="keyword">new</span> VoltageObjectAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象适配器模式注意事项和细节">5.3 对象适配器模式注意事项和细节</h3><p>1）对象适配器和类适配器其实算是一种思想，只不过实现方式不同。根据合成复用原则，使用组合代替继承，所以它解决了类适配器必须继承src类的局限性问题，也不再要求dst必须是接口。</p><p>2）使用成本更低，更灵活。</p><h2 id="接口适配器模式">6. 接口适配器模式</h2><h3 id="接口适配器模式介绍">6.1 接口适配器模式介绍</h3><p>1）一些书籍称为：适配器模式（Default Adapter Pattern）或缺省适配器模式。</p><p>2）核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每一个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</p><p>3）适用于一个接口不想使用其所有的方法的情况。</p><h3 id="接口适配器模式应用实例">6.3 接口适配器模式应用实例</h3><p>1）Android中的属性动画ValueAnimator类可以通过addListen（AnimatorListener listener）方法添加监听器，那么常规写法如右图</p><p>2）有时候我们不想实现Animator.AnimatorListener接口的全部方法，我们只想监听onAnimationStart，我们写如左图一样选择性写</p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-18-image-20221127181638609.png" alt><figcaption>image-20221127181638609</figcaption></figure><p>3）AnimatorListenerAdapter类，就是一个接口适配器，代码如右图：它空实现了Animator.AnimatorListener(src)的所有方法</p><p>4）而AnimatorListener是一个接口，如左图</p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-18-image-20221127181837791.png" alt><figcaption>image-20221127181837791</figcaption></figure><p>5）程序里的匿名内部类就是Listener具体实现类，只重写了其中关心的方法</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-18-image-20221127181934496.png" alt="image-20221127181934496" style="zoom:67%;"></p><p>6）案例说明</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-18-image-20221127182347824.png" alt="image-20221127182347824" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Adapter中，将Interface4中的所有方法默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter()&#123;</span><br><span class="line">            <span class="comment">//只需要去覆盖我们要使用的方法就好</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用m2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        absAdapter.m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式在springmvc框架应用的源码分析">7. 适配器模式在SpringMVC框架应用的源码分析</h2><p>1）SpringMVC中的HandlerAdapter就使用了适配器模式</p><p>2）SpringMVC处理请求的流程回顾</p><p>3）使用HandlerAdapter的原因分析：可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断使用if else来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样就违背了OCP原则</p><p>4）代码分析+Debug源码</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-21-image-20221127210710631.png" alt="image-20221127210710631" style="zoom:80%;"></p><p>5）动手写SpringMVC通过适配器设计模式获取到对应的Controller的源码</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-18-image-20221127183657533.png" alt="image-20221127183657533" style="zoom: 80%;"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-18-image-20221127183718370.png" alt="image-20221127183718370"></p><p>DispatchServlet组合了所有Adapter，通过doDispatch来调用</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-27-21-image-20221127211725086.png" alt="image-20221127211725086" style="zoom:67%;"></p><h2 id="适配器模式的注意事项和细节">8. 适配器模式的注意事项和细节</h2><p>1）三种命名方式是根据src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。</p><p>2）三种适配器</p><ul><li>类适配器：以类给到，在Adapter里就是将src当作类，继承</li><li>对象适配器：以对象给到，在Adapter里就是将src作为一个对象，持有（聚合关系）</li><li>接口适配器：以接口给到，在Adapter里就是将src作为一个接口，实现</li></ul><p>3）Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作</p><p>4）实际开发中，实现起来不拘泥于这三种经典形式，还有更多的形式</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/posts/709379917/"/>
      <url>/posts/709379917/</url>
      
        <content type="html"><![CDATA[<h2 id="具体需求">1. 具体需求</h2><p><strong>盖房子项目的需求：</strong></p><p>1）需要建房子：这个过程为打桩、砌墙、封顶</p><p>2）房子有各种各样的，比如普通房、高楼、别素……，各种房子的过程虽然一样，但是要求不同，比如打的地基深度不一样</p><p>3）请编写程序，完成需求</p><h2 id="传统解决方式">2. 传统解决方式</h2><p>1）思路分析（图解）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-26-23-image-20221126232003952.png" alt="image-20221126232003952" style="zoom:67%;"></p><p>2）代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbstractHouse</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Common house build base."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Common house build walls."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Common house roof."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        commonHouse.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）问题分析</p><p>1）优点是比较好理解，简单易操作</p><p>2）设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好。也就是说，这种设计方案，把产品(即：房子）和创建产品的过程(即：建房子流程）封装在一起，耦合性增强了。 3） 解决方案：将产品和产品建造过程解耦 —＞建造者模式</p><h2 id="建造者模式解决方案">3. 建造者模式解决方案</h2><h3 id="基本介绍">3.1 基本介绍</h3><p>1）建造者模式 （Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 2） 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h3 id="建造者模式的四个角色">3.2 建造者模式的四个角色</h3><p>1） <strong>Product</strong>（产品角色）：一个具体的产品对象。 2）<strong>Builder</strong>（抽象建造者）：创建一个Product 对象的各个部件指定的<strong>接口/抽象类</strong>，作为一个抽象层作为缓冲。（指定建造一个产品的流程，不关心具体细节，由具体建造者来实现） 3）<strong>ConcreteBuilder</strong>（具体建造者）：实现接口，构建和装配各个部件。 4） <strong>Director</strong>（指挥者）：构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p><h3 id="原理图">3.3 原理图</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-26-23-image-20221126233047849.png" alt="image-20221126233047849" style="zoom:67%;"></p><h3 id="应用实例">3.4 应用实例</h3><p>1）类图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-26-23-image-20221126233816510.png" alt="image-20221126233816510" style="zoom:67%;"></p><p>2）代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Product</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBaise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaise</span><span class="params">(String baise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoofed</span><span class="params">(String roofed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//组合关系</span></span><br><span class="line">    <span class="keyword">protected</span> House house =  <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造的流程写好，抽象的方法</span></span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造好房子，将产品返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Common house build basic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Common house build walls"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Common house roofed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighBuilding</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"High building build basic 100m."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"High building build wall 20cm."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"High building roofed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Director, 这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    <span class="comment">//聚合关系</span></span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从构造器传入houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter方法传入houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何处理建造房子的流程，交给这个指挥者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//普通房子，ConcreteBuilder</span></span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        <span class="comment">//准备建房子的指挥者</span></span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line">        <span class="comment">//完成盖房子，返回产品</span></span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line"></span><br><span class="line">        houseDirector.setHouseBuilder(<span class="keyword">new</span> HighBuilding());</span><br><span class="line">        house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式在jdk的应用和源码分析">4. 建造者模式在JDK的应用和源码分析</h2><p>1）java.lang.StringBuilder中的建造者模式</p><p>2）代码说明+Debug源码分析</p><p>3）源码中建造者模式角色分析</p><ul><li>Appendable接口定义了多个append方法（抽象方法），即Appendable为抽象建造者，它定义了抽象方法。</li><li>AbstractStringBuild实现了Appendable借口方法，这里的AbstractStringBuild已经是建造者，只是不能实例化。</li><li>StringBuild既充当了指挥者角色，又充当了具体的建造者，建造方法的实现是由AbstractStringBuild完成，而StringBuild继承了AbstractStringBuild。</li></ul><h2 id="建造者模式的注意事项和细节">5. 建造者模式的注意事项和细节</h2><p>1）客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 2） 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，<strong>用户使用不同的具体建造者即可得到不同的产品对象可以更加精细地控制产品的创建过程</strong>。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程 4）<strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则（OCP原则）” 5） 建造者模式<strong>所创建的产品一般具有较多的共同点</strong>，其组成部分相似（流程一样），<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制 6） 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式</p><p>7）<strong>抽象工厂模式 VS建造者模式</strong> 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/posts/153761970/"/>
      <url>/posts/153761970/</url>
      
        <content type="html"><![CDATA[<h2 id="具体需求">1. 具体需求</h2><p><strong>克隆羊问题：</strong></p><p>现在有一只羊tom，姓名为tom，年龄为1，颜色为白色，请编写程序创建和tom羊属性完全相同的10只羊。</p><h2 id="传统解决方式">2. 传统解决方式</h2><p>1）思路分析</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-25-11-image-20221125114457784.png" alt="image-20221125114457784" style="zoom:70%;"></p><p>2）代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sheep class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String color;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Sheep [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", color="</span> + color + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端创建10只羊代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//传统方法</span></span><br><span class="line">Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);</span><br><span class="line"></span><br><span class="line">Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">Sheep sheep4 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">Sheep sheep5 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">System.out.println(sheep);</span><br><span class="line">System.out.println(sheep2);</span><br><span class="line">System.out.println(sheep3);</span><br><span class="line">System.out.println(sheep4);</span><br><span class="line">System.out.println(sheep5);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）传统方式的优缺点</p><ul><li>优点是比较好理解，简单易操作</li><li>缺点是在创建新对象的时候，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活</li></ul><p>4）改进思路</p><p>Java中Object类是所有类的根类，Object类提供了一个<strong>clone()方法</strong>，该方法可以将一个Java对象复制一份，但是要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力-&gt;<strong>原型模式</strong></p><h2 id="原型模式解决方式">3. 原型模式解决方式</h2><h3 id="基本介绍">3.1 基本介绍</h3><p>1） 原型模式(Prototype 模式)是指：用原型实例指定创建对象的种类，并且通过<strong>拷贝</strong>这些原型，<strong>创建新的</strong>对象 2） 原型模式是一种<strong>创建型设计模式</strong>，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节 3）工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象<strong>通过请求原型对象拷贝它们自己</strong>来实施创建，即<code>对象.clone()</code> 4） 形象的理解：孙大圣拔出猴毛，变出其它孙大圣</p><h3 id="原理图">3.2 原理图</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-25-12-image-20221125121040062.png" alt="image-20221125121040062" style="zoom:67%;"></p><p>原理图说明：</p><p>1）Prototype：原型类，声明一个克隆自己的接口</p><p>2）ConcretePrototype：具体的原型类，实现一个克隆自己的操作</p><p>3）Clint：客户端，让一个原型对象克隆自己，从而创建一个新的对象（属性一样）</p><h3 id="应用实例">3.3 应用实例</h3><p>使用原型模式改进传统方式，让程序具有更高的效率和扩展性。</p><p>代码实现：</p><ol type="1"><li>写原型类，实现Cloneable，重写clone方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prototype</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SheepPrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SheepPrototype</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sheep [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", color="</span> + color + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//克隆该实例，使用默认的clone方法来完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SheepPrototype sheepPrototype = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheepPrototype = (SheepPrototype)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheepPrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SheepPrototype sheep = <span class="keyword">new</span> SheepPrototype(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"white"</span>);</span><br><span class="line">        SheepPrototype sheep2 = (SheepPrototype) sheep.clone();<span class="comment">//克隆</span></span><br><span class="line">        SheepPrototype sheep3 = (SheepPrototype) sheep.clone();</span><br><span class="line">        SheepPrototype sheep4 = (SheepPrototype) sheep.clone();</span><br><span class="line">        SheepPrototype sheep5 = (SheepPrototype) sheep.clone();</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        System.out.println(sheep2.toString());</span><br><span class="line">        System.out.println(sheep3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的是克隆，两个对象只是属性相同，并不==</p><h2 id="原型模式在spring框架中源码分析">4. 原型模式在Spring框架中源码分析</h2><p>1）Spring中原型bean的创建，就是原型模式的应用</p><p>2）代码分析+Debug源码</p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-25-16-image-20221125164741778.png" alt><figcaption>image-20221125164741778</figcaption></figure><h2 id="深入讨论-深拷贝和浅拷贝">5. 深入讨论-深拷贝和浅拷贝</h2><h3 id="浅拷贝基本介绍">5.1 浅拷贝基本介绍</h3><p>1）对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是<strong>将该属性值复制一份给新的对象</strong>。 2） 对于数据类型是<strong>引用数据类型的成员变量</strong>，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的<strong>引用值(内存地址）复制</strong>一份给新的对象。因为实际上两个对象的该成员变量都<strong>指向同一个实例</strong>。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。（对象的属性没有真正的复制，而是指向同一个空间）</p><p>3）前面我们克隆羊就是浅拷贝</p><p>4）浅拷贝是使用默认的clone() 方法来实现</p><p><code>sheepPrototype = (SheepPrototype)super.clone();</code></p><h3 id="深拷贝基本介绍">5.2 深拷贝基本介绍</h3><p>1）复制对象的所有基本数据类型的成员变量值 2）为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(<strong>包括对象的引用类型</strong>)进行拷贝</p><ul><li>深拷贝实现方式 1：重写 clone 方法来实现深拷贝</li><li>深拷贝实现方式2：通过对象序列化实现深拷贝(推荐） ### 5.3 深拷贝应用实例 1）使用重写clone方法实现深拷贝 2）使用序列化来实现深拷贝</li></ul><ol start="3" type="1"><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Target</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为这个类的属性都是String（基本数据类型），所以用默认的clone方法就可以完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Prototype</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 数据类型</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝 - 方式1：使用clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object deep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 这里完成基本数据类型的属性以及String属性的克隆</span></span><br><span class="line">        deep = <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 对引用数据类型的属性，单独进行处理</span></span><br><span class="line">        DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">        <span class="comment">// 因为要克隆的引用数据类型本身也实现了clone方法，所以直接调用他的克隆来赋值完成克隆</span></span><br><span class="line">        deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝 - 方式2：通过对象的序列化（推荐）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>); <span class="comment">// 当前这个对象以对象流的方式输出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DeepProtoType deepProtoType = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        deepProtoType.name = <span class="string">"A"</span>;</span><br><span class="line">        deepProtoType.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">"Target"</span>,<span class="string">"ooo"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DeepProtoType clone = (DeepProtoType) deepProtoType.clone();</span><br><span class="line">            System.out.println(<span class="string">"-----方式1-----"</span>);</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + deepProtoType.name + <span class="string">" deepCloneTarget hashcode = "</span> + deepProtoType.deepCloneableTarget.hashCode());</span><br><span class="line">            System.out.println(<span class="string">"----After Deep Clone---"</span>);</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + clone.name + <span class="string">" deepCloneTarget hashcode = "</span> + clone.deepCloneableTarget.hashCode());</span><br><span class="line"></span><br><span class="line">            DeepProtoType clone2 = (DeepProtoType) deepProtoType.deepClone();</span><br><span class="line">            System.out.println(<span class="string">"-----方式2-----"</span>);</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + deepProtoType.name + <span class="string">" deepCloneTarget hashcode = "</span> + deepProtoType.deepCloneableTarget.hashCode());</span><br><span class="line">            System.out.println(<span class="string">"----After Deep Clone---"</span>);</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + clone2.name + <span class="string">" deepCloneTarget hashcode = "</span> + clone2.deepCloneableTarget.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式注意事项和细节">6. 原型模式注意事项和细节</h2><p>1）创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。 2） 不用重新初始化对象，而是动态地获得对象运行时的状态。 3） 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。 4） 在实现深克隆的时候可能需要比较复杂的代码 <strong>缺点：</strong>需要为每一个类配备一个克隆方法，这对全新的类來说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp 原则。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/posts/3439274786/"/>
      <url>/posts/3439274786/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式">1. 简单工厂模式</h2><h3 id="具体需求">1.1 具体需求</h3><p>一个披萨项目：要便于披萨种类的扩展，要便于维护。</p><p>1）披萨的种类很多（比如GreekPizz、CheesePizz等）</p><p>2）披萨的制作有prepare、bake、cut、box……</p><p>3）完成披萨店的订购功能</p><h3 id="传统实现方法">1.2 传统实现方法</h3><p>1）思路分析（类图）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-23-17-image-20221123174559239.png" alt="image-20221123174559239" style="zoom:65%;"></p><p>编写OrderPizza.java去订购需要的各种pizza</p><p>2）代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">  <span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">String orderType; <span class="comment">// 订购的披萨类型</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">pizza.setName(<span class="string">" 希腊披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">pizza.setName(<span class="string">" 奶酪披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">pizza.setName(<span class="string">" 胡椒披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出pizza 制作过程</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）优缺点</p><ol type="1"><li>优点是比较好理解，简单易操作</li><li>缺点是违反了设计模式的<strong>OCP原则</strong>，即对扩展开放，对修改关闭。即当我们给类新增加功能时，尽量不修改代码，或者尽可能少的修改代码。</li><li>例如，当我们要新增加一个pizza的种类时，需要做如下修改<ul><li>新增一个pizza类</li><li>在OrderPizza构造器中增加else……if语句</li></ul></li></ol><p>4）改进思路分析</p><ol type="1"><li>分析：修改代码可以接受，但是如果我们在其他地方也有创建pizza的代码，就意味着，也要修改，而创建pizza的代码，往往有多处，就要在很多处修改</li><li>思路：把创建pizza对象封装到一个类中，这样我们有新的pizza种类时，只需要修改该类就可，其他有创建到pizza对象的代码就不需要修改了——&gt;简单工厂模式</li></ol><h3 id="简单工厂模式方法">1.3 简单工厂模式方法</h3><h4 id="基本介绍">1.3.1 基本介绍</h4><ol type="1"><li>简单工厂模式时属于<strong>创建型模式</strong>，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）</li><li>在软件开发中，当我们会用到大量的创建某种、某类或某批对象时，就会用到工厂模式</li></ol><h4 id="使用简单工厂模式">1.3.2 使用简单工厂模式</h4><p>1）简单工厂模式的设计方案：定义一个可以实例化pizza对象的 类，封装创建对象的代码，创建的部分只需要跟工厂类产生依赖，不需要跟pizza产生依赖了</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-23-18-image-20221123183316357.png" alt="image-20221123183316357" style="zoom:67%;"></p><p>2）代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更加orderType 返回对应的Pizza 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"使用简单工厂模式"</span>);</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">pizza.setName(<span class="string">" 希腊披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">pizza.setName(<span class="string">" 奶酪披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">pizza.setName(<span class="string">" 胡椒披萨 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单工厂模式，也叫静态工厂模式 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza2</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"使用简单工厂模式2"</span>);</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">pizza.setName(<span class="string">" 希腊披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">pizza.setName(<span class="string">" 奶酪披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">pizza.setName(<span class="string">" 胡椒披萨 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">SimpleFactory simpleFactory;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">setFactory(simpleFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">String orderType = <span class="string">""</span>; <span class="comment">//用户输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType(); </span><br><span class="line">pizza = <span class="keyword">this</span>.simpleFactory.createPizza(orderType);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出pizza</span></span><br><span class="line"><span class="keyword">if</span>(pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">" 订购披萨失败 "</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.println(<span class="string">"input pizza type:"</span>);</span><br><span class="line">String str = strin.readLine();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">String orderType = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line">      <span class="comment">//直接用简单工厂类调用静态方法</span></span><br><span class="line">pizza = SimpleFactory.createPizza2(orderType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出pizza</span></span><br><span class="line"><span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购成功</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">" 披萨订购失败！ "</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式">2. 工厂方法模式</h2><h3 id="新需求">2.1 新需求</h3><p>披萨项目的新需求：</p><p>客户在点披萨时，可以点不同口味的披萨，比如北京的奶酪pizza、北京的胡椒pizza或者伦敦的奶酪pizza、伦敦的胡椒pizza……</p><h3 id="思路1使用简单工厂模式">2.2 思路1：使用简单工厂模式</h3><p>使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory等等。从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好。</p><h3 id="思路2使用工厂方法模式">2.3 思路2：使用工厂方法模式</h3><p>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</p><h4 id="基本介绍-1">2.3.1 基本介绍</h4><p>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式<strong>将对象实例化推迟到子类。</strong></p><h4 id="实际使用">2.3.2 实际使用</h4><p>1）思路分析</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-23-19-image-20221123195002955.png" alt="image-20221123195002955" style="zoom:67%;"></p><p>2）代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line">pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类实现</span></span><br><span class="line"><span class="comment">//输出pizza 制作过程</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.println(<span class="string">"input pizza 种类:"</span>);</span><br><span class="line">String str = strin.readLine();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> LDCheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> LDPepperPizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String loc = <span class="string">"bj"</span>;</span><br><span class="line"><span class="keyword">if</span> (loc.equals(<span class="string">"bj"</span>)) &#123;</span><br><span class="line"><span class="comment">//订购北京口味的Pizza</span></span><br><span class="line"><span class="keyword">new</span> BJOrderPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//订购伦敦口味的Pizza</span></span><br><span class="line"><span class="keyword">new</span> LDOrderPizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式">3. 抽象工厂模式</h2><h3 id="基本介绍-2">3.1 基本介绍</h3><p>1）抽象工厂模式：定义了一个<strong>interface</strong>用于创建相关或有依赖关系的对象簇，而无需指明具体的类</p><p>2）抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合</p><p>3）从设计层面看，抽象工厂模式就是简单工厂模式的改进（或称为进一步的抽象）</p><p>4）将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</p><h3 id="应用实例">3.2 应用实例</h3><p>1）类图</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-23-20-image-20221123201343017.png" alt="image-20221123201343017" style="zoom:67%;"></p><p>2）代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层（接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"~使用的是抽象工厂模式~"</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>))&#123;</span><br><span class="line">pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"~使用的是抽象工厂模式~"</span>);</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> LDCheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> LDPepperPizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AbsFactory factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">setFactory(factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">String orderType = <span class="string">""</span>; <span class="comment">// 用户输入</span></span><br><span class="line"><span class="keyword">this</span>.factory = factory;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">orderType = getType();</span><br><span class="line"><span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">pizza = factory.createPizza(orderType);</span><br><span class="line"><span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购成功</span></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"订购失败"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.println(<span class="string">"input pizza 种类:"</span>);</span><br><span class="line">String str = strin.readLine();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//new OrderPizza(new BJFactory());</span></span><br><span class="line"><span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> LDFactory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式在jdk-calendar应用的源码分析">4. 工厂模式在JDK-Calendar应用的源码分析</h2><p>1）JDK中的Calendar类中，就使用了简单工厂模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>Debug可以看到具体创建流程</p><h2 id="工厂模式小结">5. 工厂模式小结</h2><p>1）工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目（如Pizza）的依赖关系的解耦，从而提高项目的扩展和维护性。</p><p>2） 三种工厂模式（简单工厂模式、工厂方法模式、抽象工厂模式）</p><p>3） 设计模式的<strong>依赖抽象原则</strong></p><ul><li>创建对象实例时，不要直接 new 类，而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口）</li><li>不要覆盖基类中已经实现的方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/posts/1776793711/"/>
      <url>/posts/1776793711/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式的介绍">1. 单例模式的介绍</h3><p>所谓的单例模式，就是采取一定的方法，保证在整个的软件系统中，==对某个类只能存在一个对象实例==，并且该类只提供一个取得起对象实例的方法（静态方法）。</p><h3 id="单例模式的八种方式">2. 单例模式的八种方式</h3><ol type="1"><li>==饿汉式（静态常量）==</li><li>==饿汉式（静态代码块）==</li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li>==双重检查==</li><li>==静态内部类==</li><li>==枚举==</li></ol><h4 id="饿汉式静态常量">2.1 饿汉式（静态常量）</h4><p>饿汉式（静态常量）应用实例</p><p><strong>步骤如下：</strong></p><p>1）构造器私有化（防止new）</p><p>2）类的内部创建对象</p><p>3）向外暴露一个静态的公共方法。getInstance</p><p>4）代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式（静态变量）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 构造器私有化（防止外部new）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 类的内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 向外提供一个静态的公共方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p><strong>缺点：</strong>在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p><p>这种方式基于 classloder 机制<strong>避免了多线程的同步问题</strong>，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getinstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到lazy loading 的效果</p><p><strong>结论：</strong>这种单例模式可用，<strong>可能</strong>造成内存浪费</p><h4 id="饿汉式静态代码块">2.2 饿汉式（静态代码块）</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 构造器私有化，外部不能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line"><span class="keyword">static</span> &#123; </span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>这种方式和上面的方式其实是类似的，只不过将类实例化的过程放在静态代码块中，也就是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p><p><strong>结论：</strong>这种单例模式可用，但是可能造成内存浪费</p><h4 id="懒汉式线程不安全">2.3 懒汉式（线程不安全）</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>1）起到了lazy loading的效果，但是只能在单线程下使用。</p><p>2）如果在多线程下，一个线程进入了if(singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时会产生多个实例，所以在多线程环境下不可使用这种方式。</p><p><strong>结论：</strong>在实际开发中，不要使用这种方式。</p><h4 id="懒汉式线程安全同步方法">2.4 懒汉式（线程安全，同步方法）</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式（线程安全）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">  <span class="comment">//synchronized修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>1）解决了线程安全问题</p><p>2）效率太低了，每个线程在想获得类的实例的时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想要获得该类实例，直接return就行了。<strong>方法进行同步效率太低。</strong></p><p><strong>结论：</strong>在实际开发中，<strong>不推荐</strong>使用这种方式。</p><h4 id="懒汉式线程安全同步代码块">2.5 懒汉式（线程安全，同步代码块）</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//同步代码块，无法解决线程安全问题</span></span><br><span class="line">  <span class="comment">//会有多个线程执行if语句</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>1）这种方式本意是要对上一个方式进行改进，因为上一个方式效率太低，从而改为同步产生实例化的代码块。</p><p>2）但是这种同步<strong>并不能起到线程同步的作用</strong>。跟2.3的情况一样，如果在多线程下，一个线程进入了if(singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时会产生多个实例。</p><p><strong>结论：</strong>在实际开发中，不推荐使用这种方式。</p><h4 id="双重检查">2.6 双重检查</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式（线程安全，同步方法和代码块，双重检查）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//volatile修饰，相当于轻量级的synchronized</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span></span><br><span class="line">  <span class="comment">//同时保证了效率，强烈推荐使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//保证只有一个线程执行这个代码块来进行实例化</span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>1）Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (instance == null)检查，这样就可以保证线程安全。</p><p>2）这样，实例化代码只用执行一次，后面再次访问时，判断if(instance == null)，直接return实例化对象，也避免了反复进行方法同步。</p><p>3）线程安全；延迟加载；效率较高</p><p><strong>结论：</strong>在实际开发中，<strong>推荐使用</strong>这种单例设计模式。</p><h4 id="静态内部类">2.7 静态内部类</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成，推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个静态内部类，该类中有一个静态属性 Singleton</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，同时同步方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>1）这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p><p>2）静态内部类方式在Singleton类被装载时不会立即实例化，而是在需要实例化时，调用getInstance方法，才会被装载SingletonInstance类，从而完成Singleton的实例化。</p><p>3）类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全，在类进行初始化时，别的线程时无法进入的。</p><p>4）避免了线程不安全，利用静态内部类特点实现延迟加载，<strong>效率高</strong></p><p><strong>结论：</strong>推荐使用。</p><h4 id="枚举">2.8 枚举</h4><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例，推荐</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">INSTANCE; <span class="comment">//属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton instance = Singleton.INSTANCE;</span><br><span class="line">Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">System.out.println(instance == instance2);</span><br><span class="line"></span><br><span class="line">System.out.println(instance.hashCode());</span><br><span class="line">System.out.println(instance2.hashCode());</span><br><span class="line"></span><br><span class="line">instance.sayOK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><p>1）借助JDK1.5中添加的枚举类来实现单例模式。不仅能够避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p><p>2）这种方式时Effective Java作者Josh Bloch提倡的方式</p><p><strong>结论：</strong>推荐使用。</p><h3 id="单例模式在jdk应用的源码分析">3. 单例模式在JDK应用的源码分析</h3><p>1）在JDK中，java.lang.Runtime就是静单的单例模式（饿汉式）</p><p>2）代码分析</p><h3 id="单例模式注意事项和细节说明">4. 单例模式注意事项和细节说明</h3><p>1）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</p><p>2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是用new。</p><p>3）单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板</title>
      <link href="/posts/750975640/"/>
      <url>/posts/750975640/</url>
      
        <content type="html"><![CDATA[<h2 id="广度优先搜索bfs">1. 广度优先搜索BFS</h2><p>数据结构：Queue队列</p><p>使用广度优先搜索（ BFS ）的两个主要方案：<code>遍历</code>或<code>找出最短路径</code>，通常发生在树或图中。</p><p>在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。</p><h3 id="bfs-模板i">1.1 BFS-模板I</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，在每一轮中，队列中的结点是等待处理的结点。 在每个更外一层的 while 循环之后，我们距离根结点更远一步。变量 step 指示从根结点到我们正在访问的当前结点的距离</p><h3 id="bfs-模板ii">1.2 BFS-模板II</h3><p>有时，确保我们永远<code>不会访问一个结点两次</code>很重要。否则，我们可能陷入无限循环。</p><p>如果是这样，我们可以在上面的代码中添加一个哈希集<code>used</code>or<code>visited</code>来解决这个问题。这是修改后的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种情况你不需要使用哈希集：</p><ol type="1"><li>你完全确定没有循环，例如，在树遍历中；</li><li>你确实希望多次将结点添加到队列中。</li></ol><h2 id="深度优先搜索dfs">2. 深度优先搜索DFS</h2><p>数据结构：Stack栈</p><p>在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：<code>遍历顺序</code>。</p><p>与 BFS 不同，<code>更早访问的结点可能不是更靠近根结点的结点</code>。因此，你在 DFS 中找到的第一条路径<code>可能不是最短路径</code>。</p><h3 id="dfs-模板i递归">2.1 DFS-模板I（递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，使用的是由系统提供的<strong>隐式栈</strong>，也称为调用栈（<a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">Call Stack</a>）。</p><blockquote><p>在上面的模板中，我们在找到<code>第一条</code>路径时停止。</p><p>如果你想找到<code>最短</code>路径呢？</p><p>提示：再添加一个参数来指示你已经找到的最短路径。</p></blockquote><h3 id="dfs-模板ii">2.2 DFS-模板II</h3><p>递归解决方案的优点是它更容易实现。 但是，存在一个很大的缺点：如果递归的深度太高，你将遭受堆栈溢出。 在这种情况下，您可能会希望使用 BFS，或使用显式栈实现 DFS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; s;</span><br><span class="line">    add root to s;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to s;</span><br><span class="line">                add next to visited;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        remove cur from s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该逻辑与递归解决方案完全相同。 但我们使用 <code>while</code> 循环和<code>栈</code>来模拟递归期间的<code>系统调用栈</code>。</p><h2 id="双指针">3. 双指针</h2><h3 id="情景一">3.1 情景一</h3><p>使用双指针的典型场景之一是你想要：</p><blockquote><p>从两端向中间迭代数组。</p></blockquote><p>这时你可以使用双指针技巧：</p><blockquote><p>一个指针从头部开始，而另一个指针从尾部开始。</p><p>也就是从用一个指针迭代变成用两个指针迭代</p></blockquote><p>这种技巧经常在排序数组中使用。</p><ul><li>一个经典问题：</li></ul><p>反转数组中的元素。比如数组为 ['h', 'e', 'l', 'l', 'o']，反转之后变为 ['o', 'l', 'l', 'e', 'h']。</p><p>使用双指针技巧，其思想是分别将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。</p><h3 id="情景二">3.2 情景二</h3><p>需要使用双指针技巧的另一种非常常见的情况：</p><blockquote><p>同时有一个慢指针和一个快指针。</p><p>两个指针同方向移动，不同速度。</p><p>可以用来解决：滑动窗口问题</p></blockquote><p>解决这类问题的关键是:</p><blockquote><p>确定两个指针的移动策略。（有时贪心算法有关）</p><p>快指针什么时候移动？ 慢指针什么时候移动？ 快慢指针移动步数时候有联系？</p></blockquote><p>与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心法则来决定你的运动策略。</p><h2 id="二分查找">4. 二分查找</h2><p>二分查找是一种在每次比较之后将查找空间一分为二的算法。每次需要查找集合中的索引或元素时，都应该考虑二分查找。</p><p>如果集合是无序的，我们在应用二分查找之前先对其进行排序。</p><h3 id="二分查找三部分">二分查找三部分</h3><p>二分查找一般由三个主要部分组成：</p><ol type="1"><li><p><strong>预处理</strong> —— 如果集合未排序，则进行排序。</p></li><li><p><strong>二分查找</strong> —— 使用循环或递归在每次比较后将查找空间划分为两半。</p></li><li><p><strong>后处理</strong> —— 在剩余空间中确定可行的候选者。</p></li></ol><h3 id="模版i">4.1 模版I</h3><p><strong>场景：</strong>用于查找可以通过<em>访问数组中的<strong>单个索引</strong></em>来确定的元素或条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="comment">// 用减法，防止溢出</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// End Condition: left &gt; right</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始条件：<code>left = 0, right = length-1</code></li><li>终止：<code>left &gt; right</code></li><li>向左查找：<code>right = mid-1</code></li><li>向右查找：<code>left = mid+1</code></li></ul><p><strong>关键属性：</strong></p><ul><li>二分查找的最基础和最基本的形式。</li><li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</li><li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li></ul><h3 id="模版ii">4.2 模版II</h3><p><strong>场景：</strong>用于查找需要<em>访问数组中<strong>当前索引及其直接右邻居索引</strong></em>的元素或条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这边要注意right是数组的长度</span></span><br><span class="line">  <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; </span><br><span class="line">      <span class="keyword">return</span> mid; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; </span><br><span class="line">      left = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      right = mid; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始条件：<code>left = 0, right = length</code></li><li>终止：<code>left == right</code></li><li>向左查找：<code>right = mid</code></li><li>向右查找：<code>left = mid+1</code></li></ul><p><strong>关键属性：</strong></p><ul><li>一种实现二分查找的高级方法。</li><li>查找条件需要访问元素的直接右邻居。</li><li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li><li>保证查找空间在每一步中至少有 2 个元素。</li><li>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li></ul><h3 id="模版iii">4.3 模版III</h3><p><strong>场景：</strong>二分查找的另一种独特形式。 用于搜索需要<em>访问<strong>当前索引及其在数组中的直接左右邻居索引</strong></em>的元素或条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分查找 --- (left, right)</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">          <span class="comment">//  target 在右区间，在(middle, right)中</span></span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// target 在左区间，在(left, middle)中</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始条件：<code>left = 0, right = length-1</code></li><li>终止：<code>left + 1 == right</code></li><li>向左查找：<code>right = mid</code></li><li>向右查找：<code>left = mid</code></li></ul><p><strong>关键属性：</strong></p><ul><li>实现二分查找的另一种方法。</li><li>搜索条件需要访问元素的直接左右邻居。</li><li>使用元素的邻居来确定它是向右还是向左。</li><li>保证查找空间在每个步骤中至少有 3 个元素。</li><li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li></ul><h3 id="模版分析">4.4 模版分析</h3><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-21-15-template_diagram.png" alt><figcaption>img</figcaption></figure><p>三个模版的区别都用红色标记出来，它们的不同之处在于：</p><ul><li>左、中、右索引的分配。</li><li>循环或递归终止条件。</li><li>后处理的必要性。</li></ul><p>模板 #1 和 #3 是最常用的，几乎所有二分查找问题都可以用其中之一轻松实现。模板 #2 更 高级一些，用于解决某些类型的问题。</p><h4 id="模版-1-left-right">模版 #1 <code>left &lt;= right</code></h4><ul><li>二分查找的最基础和最基本的形式。</li><li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</li><li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li></ul><h4 id="模版-2-left-right">模版 #2 <code>left &lt; right</code></h4><ul><li>一种实现二分查找的高级方法。</li><li>查找条件需要访问元素的直接右邻居。</li><li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li><li>保证查找空间在每一步中至少有 2 个元素。</li><li>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li></ul><h4 id="模版-3-left-1-right">模版 #3 <code>left + 1 &lt; right</code></h4><ul><li>实现二分查找的另一种方法。</li><li>搜索条件需要访问元素的直接左右邻居。</li><li>使用元素的邻居来确定它是向右还是向左。</li><li>保证查找空间在每个步骤中至少有 3 个元素。</li><li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li></ul><p><strong>注：</strong>本篇内容主要来自几本力扣的LeetBook <a href="https://leetcode.cn/leetbook/" target="_blank" rel="noopener">(LeetCode)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式七大原则</title>
      <link href="/posts/3204582657/"/>
      <url>/posts/3204582657/</url>
      
        <content type="html"><![CDATA[<h2 id="一单一职责原则single-responsibility-principle">一、单一职责原则(Single Responsibility Principle)</h2><h3 id="基本介绍">1.1 基本介绍</h3><p>对类来说的，即一个类应该只负责一项职责，例如类A负责两个<strong>不同</strong>职责：职责1，职责2。当职责1需求变更时需要修改类A，可能会造成职责2执行错误，所以需要将A的粒度分解为A1，A2</p><h3 id="应用实例">1.2 应用实例</h3><h4 id="交通工具案例">交通工具案例</h4><ul><li>方案1违反了单一职责原则，Vehicle类承担了两个职责，导致交通工具的运行方式都在公路上，修改运行方式会影响到原本的交通工具</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-07-22-14-image-20220722140131204.png" alt="image-20220722140131204" style="zoom:50%;"></p><ul><li><p>方案2: 将Vehicle类按照运行方式分解成三个类：RoadVehicle、AirVehicle、WaterVehicle，但这样改动消耗太大，同时还需要修改客户端代码（main函数）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-image-20220722140612041.png" alt="image-20220722140612041" style="zoom:50%;"></p></li><li><p>方案3：直接修改Vehicle类，对原本的类没有做大的修改，只是增加了方法，一定程度上没有在类上遵守单一职责原则，但在方法级别上仍然遵守单一职责原则</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-image-20220722140929416.png" alt="image-20220722140929416" style="zoom:50%;"></p></li></ul><h3 id="注意事项和细节">1.3 注意事项和细节</h3><ol type="1"><li>降低了类的复杂度，一个类只负责一个职责</li><li>降低类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵循单一职责原则，只有在逻辑足够简单的情况下，才能够在代码级违反单一职责原则；只有类中的方法数量足够少，才可以在方法级别保持单一职责原则</li></ol><h2 id="二接口隔离原则interface-segregation-principle">二、接口隔离原则(Interface Segregation Principle)</h2><h3 id="基本介绍-1">2.1 基本介绍</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</p><h3 id="应用实例-1">2.1 应用实例</h3><ul><li><p>方案1: 如类图所示，类B和类D实现接口，类A通过接口依赖（使用）类B，并且只使用接口的1、2、3三个方法，而类D C通过接口依赖（使用）类D，但C中只使用接口的1、4、5三个方法。接口Interface1对于类A和类C不是最小接口，类B和类D必须去实现他们各自中不需要的方法</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-image-20220722144114905.png" alt="image-20220722144114905" style="zoom:50%;"></p></li><li><p>方案2: 按照接口隔离原则，将接口拆分成几个独立的接口，类A和类C分别与他们需要的接口建立依赖关系</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-image-20220722144951276.png" alt="image-20220722144951276" style="zoom:50%;"></p></li></ul><h2 id="三依赖倒转原则dependence-inversion-principle">三、依赖倒转原则(Dependence Inversion Principle)</h2><h3 id="基本介绍-2">3.1 基本介绍</h3><ol type="1"><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒置的核心思想是<strong>面向接口编程</strong></li><li>设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的框架比以细节为基础搭建的框架要稳定的多。例如Java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体操作，把展示细节的任务交给它们的实现类</li></ol><h3 id="应用实例-2">3.2 应用实例</h3><h4 id="完成person接收消息功能">完成Person接收消息功能</h4><ul><li><p>方案1: 完成接收Email消息功能</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-16-image-20220722164936799.png" alt="image-20220722164936799" style="zoom:50%;"></p></li><li><p>方案2: Person依赖接口，receive方法接收一个接口</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726160437972.png" alt="image-20220726160437972" style="zoom:50%;"></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726160518860.png" alt="image-20220726160518860" style="zoom:50%;"></p></li></ul><h3 id="依赖关系传递的三种方式和应用实例">3.3 依赖关系传递的三种方式和应用实例</h3><ol type="1"><li><p>接口传递</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726160917047.png" alt="image-20220726160917047" style="zoom:50%;"></p></li><li><p>构造方法传递</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726161411757.png" alt="image-20220726161411757" style="zoom:50%;"></p></li><li><p>setter方法传递</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726161537805.png" alt="image-20220726161537805" style="zoom:50%;"></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726164046602.png" alt="image-20220726164046602" style="zoom:50%;"></p></li></ol><h3 id="注意事项和细节-1">3.4 注意事项和细节</h3><ol type="1"><li><p>底层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好；</p></li><li><p>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象之间就存在一个缓冲层，有利于程序扩展和优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class B是一个抽象类</span><br><span class="line">Class A是B的实现</span><br><span class="line">B obj = <span class="keyword">new</span> A()</span><br><span class="line">obj在实际对象A之间多了一个缓冲层B，扩展功能时，只需要扩展B，A自然也会拥有</span><br></pre></td></tr></table></figure></li><li><p>继承时遵循里氏替换原则</p></li></ol><h2 id="四里氏替换原则liskov-substitution-principle">四、里氏替换原则(Liskov Substitution Principle)</h2><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-26-16-image-20220726164556017.png" alt="image-20220726164556017" style="zoom:80%;"></p><h3 id="基本介绍-3">4.1 基本介绍</h3><ol type="1"><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型，换句话说，所有引用基类的地方必须能<strong>透明</strong>地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在子类中<strong>尽量</strong>不要重写父类的方法</li><li>里氏原则表示了，继承实际让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</li></ol><h3 id="应用实例-3">4.2 应用实例</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-27-15-image-20220727151208740.png" alt="image-20220727151208740" style="zoom:67%;"></p><p>我们发现a和b对象调用func1的结果会不一样，正常的相减功能发生了错误，不满足里氏替换原则。原因就是类B无意中重写了父类A的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新功能，这样写起来虽然简单，但整个继承体系的<strong>复用性会比较差</strong>。特别是运行多态比较频繁的时候。</p><ul><li><p>解决方法：</p><p>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系替代。</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-27-16-image-20220727160158020.png" alt="image-20220727160158020" style="zoom:50%;"></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-27-15-image-20220727153626412.png" alt="image-20220727153626412" style="zoom:50%;"></p><p>若B和A仍需要产生关系，可以使用组合关系来替代</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-27-15-07-27-15-image-20220727153811445.png" alt="image-20220727153811445" style="zoom:50%;"></p></li></ul><h2 id="五开闭原则open-closed-principle">五、开闭原则(Open Closed Principle)</h2><h3 id="基本介绍-4">5.1 基本介绍</h3><ol type="1"><li>开闭原则(Open Closed Principle，OCP)是编程中最基础、最重要的设计原则；</li><li>一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节；</li><li>当软件需要变化时，尽量<strong>通过扩展</strong>软件实体的行为来实现变化，而<strong>不是通过修改</strong>已有的代码来实现变化；</li><li>编程中遵循其他原则，以及使用设计模式的目的就是遵循<strong>开闭原则</strong>。</li></ol><h3 id="应用实例-4">5.2 应用实例</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-27-16-image-20220727163827088.png" alt="image-20220727163827088" style="zoom:50%;"></p><ul><li><p>方式1:</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-27-16-image-20220727163848239.png" alt="image-20220727163848239" style="zoom:50%;"></p><ul><li><p>方式一存在的优缺点：</p><ul><li><p>优点是比较好理解，简单易操作</p></li><li><p>缺点是违反设计模式的开闭原则，即对扩展开放，对修改关闭。即当我们给类新增功能的时候，尽量不修改代码，或尽可能少的修改代码</p></li><li><p>比如现在我们要增加一个图形种类（如三角形），就需要修改较多地方：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">添加一个Triangle类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  Trianle()&#123;</span><br><span class="line">    <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">而GraphicEditor类是使用方：</span><br><span class="line">  需要增加一个drawTriangle（Shape r）方法</span><br><span class="line">  需要修改drawShape方法</span><br><span class="line">在Test类的main方法中对方法进行调用</span><br></pre></td></tr></table></figure></li><li>方式一需要修改到使用方，违背了ocp原则</li></ul></li></ul></li></ul></li><li><p>方式2:</p><ul><li><p>把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可，使用方法的代码就不需要修改，从而满足了OCP原则</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    GraphicEditor g = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">    g.drawShape(<span class="keyword">new</span> Trianle());</span><br><span class="line">    g.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">    s.draw()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m_type;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  Trianle()&#123;</span><br><span class="line">    <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"绘制圆形"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  Trianle()&#123;</span><br><span class="line">    <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"绘制三角形"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="六迪米特法则demeter-principle">六、迪米特法则(Demeter Principle)</h2><h3 id="基本介绍-5">6.1 基本介绍</h3><ol type="1"><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则又叫<strong>最少知道法则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄漏任何信息。</li><li>迪米特法则还有一个更简单的定义：只与直接的朋友通信</li><li>直接的朋友:每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，如依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，<strong>陌生的类最好不要以局部变量的形式出现在类的内部</strong>。</li></ol><h3 id="应用实例-5">6.2 应用实例</h3><p>有个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和各个学院员工ID；</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-05-16-image-20220805162350969.png" alt="image-20220805162350969" style="zoom:50%;"></p><p>该设计存在的问题：SchoolManager中的CollegeEmployee不是其直接朋友，即CollegeEmployee出现在局部变量中</p><p>按照迪米特法则，应该避免类中出现这样的非直接朋友关系的耦合。</p><p><strong>改进方法</strong>：根据迪米特法则对代码进行修改</p><ul><li>对涉及到非直接朋友的代码对进行封装，封装到直接朋友类中去，即将获取到学院员工的这段代码封装到CollegeManager类的内部</li></ul><p><img src="/Users/zerohuang/Library/Application%20Support/typora-user-images/image-20220805162749386.png" alt="image-20220805162749386" style="zoom:50%;"></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-05-16-image-20220805162928240.png" alt="image-20220805162928240" style="zoom:50%;"></p><h3 id="注意事项和细节-2">6.3 注意事项和细节</h3><ol type="1"><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</li></ol><h2 id="七合成复用原则composite-reuse-principle">七、合成复用原则(Composite Reuse Principle)</h2><h3 id="基本介绍-6">7.1 基本介绍</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-05-17-image-20220805170324565.png" alt="image-20220805170324565" style="zoom:50%;"></p><h2 id="设计原则核心思想">设计原则核心思想</h2><ol type="1"><li>找到应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 七大原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个ECharts图表</title>
      <link href="/posts/898977949/"/>
      <url>/posts/898977949/</url>
      
        <content type="html"><![CDATA[<h2 id="一获取echarts">一、获取ECharts</h2><ul><li><p>从 <a href="https://echarts.apache.org/zh/download.html" target="_blank" rel="noopener">Apache ECharts 官网下载界面</a> 获取官方源码包后构建。</p></li><li><p>在 ECharts 的 <a href="https://github.com/apache/echarts/releases" target="_blank" rel="noopener">GitHub</a> 获取。</p></li><li><p>在打包环境中，通过 npm 获取 echarts，<code>npm install echarts --save</code></p><ul><li><p>引入ECharts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二v5-升级重要更改">二、v5 升级重要更改</h2><ol type="1"><li><p>引用更改</p><p>不再支持default exports，需用用如下的引入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span>;</span><br><span class="line"><span class="comment">// 按需引入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts/lib/echarts'</span>;</span><br></pre></td></tr></table></figure></li><li><p>按需引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts/core'</span>;</span><br><span class="line"><span class="comment">// 引入柱状图图表，图表后缀都为 Chart</span></span><br><span class="line"><span class="keyword">import</span> &#123; BarChart &#125; <span class="keyword">from</span> <span class="string">'echarts/charts'</span>;</span><br><span class="line"><span class="comment">// 引入提示框，标题，直角坐标系组件，组件后缀都为 Component</span></span><br><span class="line"><span class="keyword">import</span> &#123; GridComponent &#125; <span class="keyword">from</span> <span class="string">'echarts/components'</span>;</span><br><span class="line"><span class="comment">// 注意，新的接口中默认不再包含 Canvas 渲染器，需要显示引入，如果需要使用 SVG 渲染模式则使用 SVGRenderer，这一步引入是必须的</span></span><br><span class="line"><span class="keyword">import</span> &#123; CanvasRenderer &#125; <span class="keyword">from</span> <span class="string">'echarts/renderers'</span>;</span><br><span class="line"><span class="comment">// 注册必须的组件</span></span><br><span class="line">echarts.use([BarChart, GridComponent, CanvasRenderer]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来的使用就跟之前一样，初始化图表，设置配置项</span></span><br><span class="line"><span class="comment">// 基于准备好的dom，初始化echarts实例</span></span><br><span class="line"><span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>));</span><br><span class="line">myChart.setOption(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>其他的配置项调整可以参照<a href="https://echarts.apache.org/zh/tutorial.html#ECharts%205%20%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">官方文档指南</a>进行更新</p><h2 id="三用option描述图表">三、用Option描述图表</h2><p>Option是一个大的js对象，里面可以声明一张图表的各个组件，从而满足我们对图表的各种需求。也就是Option描述了<strong>数据</strong>、<strong>数据如何映射成图形</strong>、<strong>交互行为</strong>。</p><h3 id="组件">3.1 组件</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-19-15-image-20210819155509334.png"></p><p>上图描述了Option中声明了图中出现的各个组件，能帮助我们更清晰的理解每个组件配置项。</p><p>echats中的基本组件有：<a href="https://echarts.apache.org/zh/option.html#xAxis" target="_blank" rel="noopener">xAxis</a>（直角坐标系 X 轴）、<a href="https://echarts.apache.org/zh/option.html#yAxis" target="_blank" rel="noopener">yAxis</a>（直角坐标系 Y 轴）、<a href="https://echarts.apache.org/zh/option.html#grid" target="_blank" rel="noopener">grid</a>（直角坐标系底板）、<a href="https://echarts.apache.org/zh/option.html#angleAxis" target="_blank" rel="noopener">angleAxis</a>（极坐标系角度轴）、<a href="https://echarts.apache.org/zh/option.html#radiusAxis" target="_blank" rel="noopener">radiusAxis</a>（极坐标系半径轴）、<a href="https://echarts.apache.org/zh/option.html#polar" target="_blank" rel="noopener">polar</a>（极坐标系底板）、<a href="https://echarts.apache.org/zh/option.html#geo" target="_blank" rel="noopener">geo</a>（地理坐标系）、<a href="https://echarts.apache.org/zh/option.html#dataZoom" target="_blank" rel="noopener">dataZoom</a>（数据区缩放组件）、<a href="https://echarts.apache.org/zh/option.html#visualMap" target="_blank" rel="noopener">visualMap</a>（视觉映射组件）、<a href="https://echarts.apache.org/zh/option.html#tooltip" target="_blank" rel="noopener">tooltip</a>（提示框组件）、<a href="https://echarts.apache.org/zh/option.html#toolbox" target="_blank" rel="noopener">toolbox</a>（工具栏组件）、<a href="https://echarts.apache.org/zh/option.html#series" target="_blank" rel="noopener">series</a>（系列）、...</p><p>其中，series表示的是一组要表示的数据，该图中有两组，一组用折线图表示，一组是用柱状图表示。</p><h3 id="组件的定位">3.2 组件的定位</h3><ul><li><p>基于<code>top</code> / <code>right</code> / <code>down</code> / <code>left</code> / <code>width</code> / <code>height</code> 绝对定位</p><ul><li>绝对定位是基于我们设置的eCharts容器的DOM节点</li><li>每个值可以是<strong>绝对数值</strong>或基于eCharts容器宽高的<strong>百分比</strong></li></ul><p>下图是对<code>grid</code>组件（坐标系的底板）的设置达到的效果</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-19-16-image-20210819161731813.png"></p></li><li><p>中心半径定位</p><p>如pie、sunburst 、polar，这些圆形的组件或系列用中心半径定位。</p><ul><li>一般是依据<code>center</code>(中心)和<code>radius</code>(半径)来决定为止</li></ul></li></ul><h2 id="四第一张echarts图表">四、第一张ECharts图表</h2><p>这是截止8.19日近期部分地区本土现有病例的柱状图。</p><p>我是拿腾讯新闻里国内疫情情况的json数据，提前处理提取所需要的数据，再放入option给ECharts渲染。</p><p>以下是结果展示和部分代码：</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-19-17-image-20210819170230683.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//为ECharts准备一个具备大小的DOM</span></span><br><span class="line">&lt;div id=<span class="string">"main"</span> style=<span class="string">"width: 800px; height: 600px"</span>&gt;&lt;<span class="regexp">/div&gt;    </span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    // import * as echarts from "</span>echarts<span class="string">";</span></span><br><span class="line"><span class="string">    // 基于准备好的dom，初始化echarts实例</span></span><br><span class="line"><span class="string">    var myChart = echarts.init(document.getElementById("</span>main<span class="string">"));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 指定图表的组件配置项和数据</span></span><br><span class="line"><span class="string">    var option = &#123;</span></span><br><span class="line"><span class="string">      title: &#123;</span></span><br><span class="line"><span class="string">        text: "</span>近期部分市本土现有病例<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      tooltip: &#123;&#125;,</span></span><br><span class="line"><span class="string">      legend: &#123;</span></span><br><span class="line"><span class="string">        data: ["</span>现有确诊病例<span class="string">"]</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      xAxis: &#123;</span></span><br><span class="line"><span class="string">        //这边的数据是从腾讯新闻页面拿的json数据解析出来的数组，过程我就不展开了</span></span><br><span class="line"><span class="string">        data: provinces</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      yAxis: &#123;&#125;,</span></span><br><span class="line"><span class="string">      series: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          name: "</span>现有确诊病例<span class="string">",</span></span><br><span class="line"><span class="string">          type: "</span>bar<span class="string">",</span></span><br><span class="line"><span class="string">          //这边的数据也是另外解析出来的一个数组</span></span><br><span class="line"><span class="string">          data: data</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 使用刚指定的配置项和数据显示图表。</span></span><br><span class="line"><span class="string">    myChart.setOption(option);</span></span><br><span class="line"><span class="string"> &lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECharts </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点汇总</title>
      <link href="/posts/2479963823/"/>
      <url>/posts/2479963823/</url>
      
        <content type="html"><![CDATA[<h2 id="一计算机网络概述">一、计算机网络概述</h2><h3 id="概念">1.1 概念</h3><ol type="1"><li><p>定义：计算机网络将地理位置不同的具有独立功能的多台计算机通过通信线路连接实现资源共享和信息传递的计算机系统。</p></li><li><p>组成：</p><ul><li>终端系统/资源子网：提供共享的软件资源和硬件资源</li><li>通信子网：提供信息交换的网络结点和通信线路</li></ul></li><li><p>类型：</p><ul><li><p>按照拓扑分类</p><ul><li>星型结构</li><li>树形结构</li><li>总线型结构</li><li>环形结构</li><li>网状结构</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-19-14-image-20210719140121527.png"></p></li><li><p>按照范围分类</p><ul><li>局域网<strong>LAN</strong></li><li>城域网<strong>MAN</strong></li><li>广域网<strong>WAN</strong></li><li>个人区域网<strong>PAN</strong>：蓝牙耳机、手环……</li><li>互联网<strong>Internet</strong></li></ul><p>一个学校的内部网络一般都属于（局域网）。个人区域网是在个人工作区内把个人使用的电子设备，如便携式计算机和打印机等，采用无线技术连接起来的网络，作用范围在10m左右；局域网覆盖的范围往往是地理位置上的某个区域，如某一企业或学校等；城域网一般来说是在一个城市，这种网络的连接距离可以达到10-100公里；这种网络也称为远程网，所覆盖的范围比MAN更广，它一般是在不同城市之间的LAN或者MAN网络互联，地理范围可从几百公里到几千公里。</p></li><li><p>按照传输方式分类</p><ul><li>有线网络<ul><li>IEEE802.3</li></ul></li><li>无线网络<ul><li>IEEE802.11</li><li>WLAN无线局域网（wireless）</li><li>WPAN无线个域网</li></ul></li></ul></li></ul></li></ol><h3 id="体系结构">1.2 体系结构</h3><ol type="1"><li><p>传输方式</p><ul><li>按传输方向<ul><li>单工：只能单方向传输</li><li>双工：在同一时间内，线路上只允许一个方向的数据通过</li><li>全双工：双方可以同时进行数据通信</li></ul></li><li>按传输对象<ul><li>单播：1对1</li><li>多播：1对多</li><li>广播：1对All</li></ul></li></ul></li><li><p>数据交换技术</p><ul><li>电路交换（一种实时交换，适用于实时要求高的话音通信( 全程&lt;=200 ms ) )：在通信前要通过呼叫为主、被叫用户建立一条<strong>物理连接</strong>，整个报文从源头到终点连续的传输。在传送信息时，没有任何差错控制措施，不利于传输可靠性要求高的突发性数据业务。</li><li>报文交换（采用存储－转发方式）：整个报文先传送到相邻结点，全部存储下来查找转发表，再转发到下一个结点。存储－转发时延大，随机性也大，过负荷时将会导致报文延迟 。</li><li>分组交换（可实现多路通信功能）：将一个报文分成多个分组，再传送到相邻结点，再查找转发表，转发到下一个结点。数据传输质量高、可靠性高，可使用优先级。提高了链路利用率，经济性好。</li></ul></li><li><p>通信协议和体系结构</p><ul><li><p>网络协议的三要素</p><ul><li>语法：指数据与控制信息的结构或格式，确定通信时采用的数据格式，编码及信号电平等，回答“怎么讲”；</li><li>语义：协议的语义是指对构成协议的协议元素含义的解释“讲什么” ；</li><li>时序：规定了事件的执行顺序。</li></ul></li><li><p>OSI/RM参考模型（开放式系统互连参考模型）</p><p>下层为上层服务</p><ul><li>物理层（bit）：利用传输介质为通信的网络节点之间建立、维护和释放物理连接，实现比特流的透明传输，进而为数据链路层提供数据传输服务。</li><li>数据链路层（帧）：在物理层提供服务的基础上，在通信的实体间建立数据链路连接提供点到点之间的通信，传输以帧(frame)为单位的数据包，并采取差错控制和流量控制的方法，使有差错的物理线路变成无差错的数据链路。</li><li>网络层（分组）：为分组交换网络上的不同主机提供通信服务，为以分组为单位的数据报通过通信子网选择适当的路由，并实现拥塞控制、网络互连等功能。</li><li>传输层：向用户提供端到端（end-to-end）的数据传输服务，实现为上层屏蔽低层的数据传输问题，实现对数据的控制和操作功能。</li><li>会话层：负责维护通信中两个节点之间的会话连接的建立、维护和断开，以及数据的交换。</li><li>表示层：用于处理在两个通信系统中交换信息的表示方式，主要包括数据格式变换、数据的加密与解密、数据压缩与恢复等功能。</li><li>应用层：为应用程序通过网络服务，它包含了各种用户使用的协议。</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-19-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210719162401136.jpeg" alt="img" style="zoom:70%;"></p></li><li><p>TCP/IP参考模型</p><ul><li>网络接入层——物理层+数据链路层</li><li>互联网络层（网际层）——网络层</li><li>传输层</li><li>应用层——会话层、表示层、应用层</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-19-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210719163141621.jpeg" alt="img" style="zoom:60%;"></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-19-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210719163247237.jpeg" alt="img" style="zoom:50%;"></p><p>IP over everything是指IP协议可以在各式各样的网络构成的互连网上运行，Everything over IP是指IP协议可以直接地为传输层TCP，间接地为应用层的各个协议提供服务。</p></li><li><p>分析OSI-RM和TCP/IP体系结构的对应关系</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-19-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210719163323709.jpeg" alt="img" style="zoom:67%;"></p></li></ul></li></ol><h2 id="二物理层">二、物理层</h2><h3 id="物理层的基本概念">2.1 物理层的基本概念</h3><h4 id="四大特性">2.1.1 四大特性</h4><ol type="1"><li>机械特性：（物理）接口是怎么样的</li><li>电气特性：用多少伏的电</li><li>功能特性：线路上电平电压的特性</li><li>过程特性：实现不同功能所发射信号的顺序</li></ol><h4 id="两种信号">2.1.2 两种信号</h4><ol type="1"><li>模拟讯号（连续的）特定频段的信号——有更加丰富的表现形式</li><li>数字信号（离散的）不是1就是0</li></ol><h4 id="调制和编码">2.1.3 调制和编码</h4><ol type="1"><li>调制：模拟信号的转换</li><li>编码：数字信号转换<ul><li>步骤：采样、量化、编码</li></ul></li><li>区别：<ul><li>数据可以通过编码手段专成数字信号，页可以通过调制手段将数据转为模拟信号</li><li>数字数据可以通过数字发送器转化为数字信号（编码），也可以通过调制器转化为模拟信号（调制）</li><li>模拟数据可以通过PCM编码转化为数字信号（编码），也可以通过放大器调制器转化为模拟信号（调制）</li></ul></li></ol><h4 id="传输介质">2.1.4 传输介质</h4><ol type="1"><li>双绞线：<ul><li>屏蔽双绞线STP：抗干扰强、贵</li><li>非屏蔽双绞线UTP：便宜、抗干扰弱</li><li>制作标准<ul><li>568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕</li><li>568A：1、3调换，2、6调换——&gt;绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</li></ul></li></ul></li><li>光纤<ul><li>单模光纤</li><li>多模光纤</li></ul></li><li>同轴电缆</li><li>无线：无线信号频率 IEEE802.11</li></ol><h4 id="三大部分">2.1.5 三大部分</h4><ol type="1"><li>源系统：发送数据的一端</li><li>传输系统：传输过程中的各种传输介质</li><li>目的系统：接受数据的一端</li></ol><h3 id="物理层的基本通信技术">2.2 物理层的基本通信技术</h3><h4 id="四种信道复用技术">2.2.1 四种信道复用技术</h4><p>复用技术：一种在传输路径上综合多路信道，然后恢复原机制或解除终端各信道复用技术的过程（将多种不同的信号在同一信道上进行传输，复用技术主要是用于解决不同信号传输时应该如何区分）</p><ul><li>频分复用FDM：划分不同频率来并行传输信号</li><li>时分复用TDM：划分不同时间段来传输信号</li><li>波分复用WDM：根据光波的波长进行传输（合波器耦合）</li><li>码分复用CDM：在同一时间同一频率根据传输的数据码进行区分</li></ul><h4 id="数据的传输方式">2.2.2 数据的传输方式</h4><ol type="1"><li>通过同时间传播数量分为<ul><li>串行传输</li><li>并行传输（数据以成组的方式传输）</li></ul></li><li>通过数据报文的双方行为分为<ul><li>同步传输（双方需要建立一个连接）</li><li>异步传输（接收方不需要准备好就可以接收）</li></ul></li><li>通过传输的信号分为<ul><li>基带传输：传输数字信号</li><li>频带传输：传输模拟信号 （300-3400Hz）</li></ul></li><li>传输方向：单工、半双工、全双工</li><li>传输对象：单播、组播、广播</li></ol><h2 id="三数据链路层">三、数据链路层</h2><h3 id="数据链路层基础概论">3.1 数据链路层基础概论</h3><h4 id="数据链路层的概念及功能">3.1.1 数据链路层的概念及功能</h4><ol type="1"><li>数据链路层是在物理层和网络层之间的协议，提供相邻结点的可靠数据传输。</li><li>功能：链路管理、帧同步（帧定界）、流量控制、数据和控制信息的识别、寻址、透明传输、差错控制</li></ol><h4 id="帧的概念">3.1.2 帧的概念</h4><ol type="1"><li><p><strong>帧</strong>是数据链路层的协议数据单元</p></li><li><p>组成</p><ul><li>帧头——源MAC地址、目的MAC地址、类型</li><li>数据</li><li>帧尾——校验</li></ul><p>以太网帧格式与局域网帧格式：</p></li></ol><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-20-19-image-20210720195411152.png" alt="image-20210720195411152" style="zoom:50%;"></p><h4 id="以太网数据帧中的mac和llc">3.1.3 以太网数据帧中的MAC和LLC</h4><ol type="1"><li><p>MAC 介质控制访问（对接物理层）</p><p>数据帧的封装/卸载，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性</p></li><li><p>LLC 逻辑控制访问（对接网络层）</p><p>LLC子层的主要功能为传输可靠性保障和控制，数据包的分段与重组，数据包的顺序传输。</p></li><li><p>该协议位于数据链路层，数据链路层分为<strong>上层</strong>LLC（逻辑链路控制），和<strong>下层</strong>的MAC（媒体访问控制），MAC主要负责控制与连接物理层的物理介质。</p></li></ol><h4 id="两种传输方式">3.1.4 两种传输方式</h4><ol type="1"><li>单播</li><li>广播</li></ol><h4 id="三个基本问题">3.1.5 三个基本问题</h4><ol type="1"><li>封装成帧：就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，接收端在收到物理层上交的比特流之后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和接收。如：PPP协议等</li><li>透明传输：指不管所传的数据是怎么样的比特组合，都应能够在链路上传送</li><li>差错检测：收到正确的帧就要想发送端发送确认，发送端在一定期限内如果没有收到对方的确认，就认为出现了差错，因而就要进行重传，直到收到对方的确认为止。如：奇偶校验、汉明码、CRC等</li></ol><h4 id="以太网中的设备">3.1.6 以太网中的设备</h4><ol type="1"><li>集线器Hub（物理层）共享</li><li>交换机Swith（数据链路层）独享</li><li>网桥（两个端口的交换机，两层之间）</li></ol><p>桥和以太网交换机可以划分冲突域，但是不可以划分广播域。路由器和三层交换机既可以划分冲突域，也可以划分广播域。</p><h3 id="数据链路层的通信协议">3.2 数据链路层的通信协议</h3><h4 id="冲突域和广播域">3.2.1 冲突域和广播域</h4><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-20-20-image-20210720201613556.png" alt="image-20210720201613556" style="zoom:50%;"></p><ol type="1"><li><p>冲突域</p><p>交换机的每一个端口都是一个冲突域；冲突域只能发生在一个网段</p></li><li><p>广播域</p><p>交换机的所有端口都在一个广播域，如果两个交换机直连那么这两个交换机的所有端口都在一个广播域；广播域在一个或多个网段</p></li><li><p>区别</p><ul><li>广播域可以跨网段</li><li>冲突域是基于第一层（物理域），而广播域是基于第二层（数据链路层）</li><li>HUB的所有端口都在同一个广播域、冲突域内。Switch所有端口都在同一个广播域中，而每一个端口就是一个冲突域</li><li>同一个冲突域共享带宽</li></ul></li></ol><h4 id="虚拟局域网vlan">3.2.2 虚拟局域网VLAN</h4><ol type="1"><li>定义：VLAN即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。VLAN的主机间可以直接通信，而VLAN间不能直接通信，从而将广播报文限制在一个VLAN内。</li><li>优点和目的</li></ol><ul><li>划分广播域</li><li>增强局域网的安全</li><li>提高健壮性</li><li>灵活构建工作组</li></ul><ol start="3" type="1"><li>划分VLAN的方式<ul><li>基于端口</li><li>基于子网</li><li>基于MAC地址</li><li>基于协议</li><li>基于匹配策略</li></ul></li></ol><h4 id="csmacd-检测总线型网络是否冲突">3.2.3 CSMA/CD-检测总线型网络是否冲突</h4><p>CSMA/CD即载波监听/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点，总线型网络传输数据。</p><p>CSMA/CD 在发送过程中继续检测信道。如果发现冲突，立即停止发送，并通知全网。等待随机时间后重新监听和发送。有效提高了网络传输效率。</p><p>工作原理： 载波监听 冲突检测 多路访问</p><p>四大要点：</p><ol type="1"><li>先听再发</li><li>边听边发</li><li>冲突停止</li><li>延迟后发</li></ol><h4 id="ppp点对点协议-单播">3.2.4 PPP（点对点）协议-单播</h4><ul><li>数据链路层的协议，用于封装数据帧</li><li>包含三个组成部分 将 IP 数据报封装到串行链路的方法、 链路控制协议 LCP (Link Control Protocol)、网络控制协议 NCP (Network Control Protocol)。</li><li>PPP 是面向字符的，所有的 PPP 帧的长度都是整数字节。</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721215728335.jpeg" alt="img" style="zoom:50%;"></p><ul><li>透明传输的方法<ul><li>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样，零比特自动插入/删除）。</li><li>当 PPP 用在异步传输时，就使用一种特殊的字符填充法：<ul><li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列（0x7D, 0x5E）。</li><li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列（0x7D, 0x5D）。</li><li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li></ul></li></ul></li></ul><h4 id="crc循环冗余校验">3.2.5 CRC循环冗余校验</h4><ol type="1"><li><p>循环冗余码 （CRC）是一种特殊的线性分组码。 循环冗余码各码组中的码元循环左移(或右移)，所形成的码组仍然是一个许用码组(全零码组除外)，称为循环性。 循环冗余码具有较高的检错能力。</p></li><li><p>生成多项式g(x)：在(n，k)循环码中，存在惟一的最高幂次为(n-k)，最多 k-1 个连续的 0 项，且常数项必须为1 的码多项式g(x)，此码多项式的幂次最低（0 元除外）；其它所有的码多项式都能被g(x)整除；并且g(x)是 x^n+1 的一个因式。 g(x)称为该编码集的生成多项式。</p></li><li><p>循环冗余码CRC的编码步骤（发送端）:</p><ul><li>求<span class="math inline">\(M(x)\)</span>所对应的码字，可先求<span class="math inline">\(M(x)\)</span>，并乘以<span class="math inline">\(x^{n-k}\)</span></li><li>然后被<span class="math inline">\(G(x)\)</span>除，求其余式</li><li>得<span class="math inline">\(x^rM(x)\)</span></li></ul></li><li><p>循环冗余码CRC的检错步骤:</p><p>用生成多项式<span class="math inline">\(G(x)\)</span>除接受下来的<span class="math inline">\(x^rM(x)R(x)\)</span>，如果能整除，则表明传输无差错</p></li><li><p>例题：一个报文的比特序列为1101011011通过数据链路传输，采用CRC进行差错检测，如所用的生成多项式为g(x)＝x^4＋x＋1，试说明： 1）CRC码的产生过程及所产生的发送序列； 2）CRC码的检测过程（有差错及无差错）。</p></li></ol><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-20-21-image-20210720212547562.png" alt><figcaption>image-20210720212547562</figcaption></figure><h2 id="四网络层">四、网络层</h2><h3 id="网络层作用">4.1 网络层作用</h3><p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。（提供端到端的服务）</p><p>单位：分组</p><h3 id="网际层协议ip">4.2 网际层协议IP</h3><h4 id="arp地址解析协议">4.2.1 ARP地址解析协议</h4><ul><li>解决同一个物理网络上的主机或路由器的 IP 地址和硬件地址的映射问题。（根据IP地址获取物理地址）</li><li>如果目的主机和源主机不在同一个局域网上，先选路，再通过 ARP 找到下一跳路由器在本 LAN 的硬件地址，然后把分组发送给它，让它把分组转发给下一个网络。从IP地址到硬件地址的解析是自动进行的，是由主机所运行的TCP/IP内核实现的。</li><li><strong>RARP（反向的地址解析协议）</strong>的作用是完成物理地址到IP地址的解析。</li></ul><h4 id="icmp网际控制报文协议">4.2.2 ICMP网际控制报文协议</h4><ul><li>ICMP允许主机或路由器向源站报告差错情况和异常情况，还包括提供信息的功能。即通过ICMP传输控制信息，控制信息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息，如ping命令。</li><li>ICMP报文分为两大类：差错报告报文和询问报文。 差错报告报文有：目的不可达报文、超时报文、源抑制报文等。 提供信息的报文有：回应请求与应答报文、时间戳请求与应答报文、地址掩码请求与应答报文等。</li></ul><h4 id="igmp网际组管理协议">4.2.3 IGMP网际组管理协议</h4><ul><li>IGMP是用于管理网路协议多播组成员的一种通信协议</li><li>IP主机和相邻的路由器利用IGMP来创建多播组的组成员。组播方式解决了单播情况下数据的重复拷贝及带宽的重复占用，也解决了广播方式下带宽资源的浪费。</li></ul><h4 id="ip数据报">4.2.4 IP数据报</h4><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-20-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721204122293.jpeg" alt="img" style="zoom:80%;"></p><ul><li><p>版本——4 bit，指IP协议的版本</p></li><li><p>首部长度—— 4 bit，单位是4字节，最大值是60字节</p></li><li><p>总长度——16bit，首部和数据之和的长度，单位为字节 总长度必须不超过最大传送单元 MTU，以太网中MTU最大值1500</p></li><li><p>标识(identification) ——16bit，一个计数器，用来产生 数据报的标识。当数据报需要分片时， 此标识表示同一个数据报的分片</p></li><li><p>标志(flag)—— 3 bit， 1位保留， DF位用来表示 数据报是否允许分片，MF位表示是否有后续分片</p></li><li><p>片偏移——13 bit，分片在原分组中的相对位置，以 8 个字节为偏移单位</p></li><li><p>生存时间<strong>TTL</strong>(Time To Live)——8bit，数据报在网络中的寿命，其单位为秒。在目前的实际应用中，以“跳”为单位</p></li><li><p>协议——8 bit，字段指出此数据报携带的数据使用何种协议 以便目的主机的 IP 层将数据部分上交给相应处理过程</p><table><thead><tr class="header"><th style="text-align: center;">协议字段值</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">6</th><th style="text-align: center;">8</th><th style="text-align: center;">17</th><th style="text-align: center;">88</th><th>89</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">协议名</td><td style="text-align: center;">ICMP</td><td style="text-align: center;">IGMP</td><td style="text-align: center;">GGP</td><td style="text-align: center;">IP</td><td style="text-align: center;">TCP</td><td style="text-align: center;">EGP</td><td style="text-align: center;">UDP</td><td style="text-align: center;">IGRP</td><td>OSPF</td></tr></tbody></table></li><li><p>首部检验和——16 bit，只检验数据报的首部 ，不包括数据部分，采用简单的计算方法</p></li><li><p>源地址和目的地址都各占 4 字节（32bit）</p></li></ul><h3 id="ip地址">4.3 IP地址</h3><h4 id="ip地址的概念">4.3.1 IP地址的概念</h4><ol type="1"><li>IP地址：是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li><li>组成：一个IP地址由4个字节，32位组成，一般用点分十进制的方式表现。</li><li>IP地址和MAC地址的区别：<ul><li>IP地址是一个逻辑地址，MAC地址是一个物理地址</li><li>MAC地址是唯一的，但IP地址不是唯一的</li><li>MAC地址主要是工作在第二层，IP地址在网络层</li><li>MAC地址是48位的，而IP地址一般是32位（IPv6时128位）</li><li>IP地址的分配取决于网络拓扑，MAC地址分配取决于制造商</li></ul></li></ol><h4 id="ip地址的组成">4.3.2 IP地址的组成</h4><ul><li>组成：<ul><li>网络地址/网络号：标识某一个网段的地址</li><li>主机地址/主机号：标识某一台设备的地址</li></ul></li><li>子网掩码：用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。<ul><li>网络号、子网号全1</li><li>主机号全0</li></ul></li></ul><h4 id="ip地址的分类">4.3.3 IP地址的分类</h4><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-15-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721154042338.jpeg" alt="img" style="zoom:80%;"></p><table><thead><tr class="header"><th style="text-align: center;">网络类别</th><th style="text-align: center;">最大网络数</th><th style="text-align: center;">最后一个可用的网络号</th><th style="text-align: center;">第一个可用的网络号</th><th style="text-align: center;">网络最大的主机数</th><th style="text-align: center;">默认子网掩码</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">126（<span class="math inline">\(2^7-1\)</span>）</td><td style="text-align: center;">1</td><td style="text-align: center;">126</td><td style="text-align: center;">16,777,214</td><td style="text-align: center;">255.0.0.0</td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">16,384（<span class="math inline">\(2^14\)</span>）</td><td style="text-align: center;">128.0</td><td style="text-align: center;">191.255</td><td style="text-align: center;">65,534</td><td style="text-align: center;">255.225.0.0</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">2,097,152（<span class="math inline">\(2^21\)</span>）</td><td style="text-align: center;">192.0.0</td><td style="text-align: center;">223.255.255</td><td style="text-align: center;">254</td><td style="text-align: center;">255.255.255.0</td></tr></tbody></table><ul><li>特殊地址<ul><li>网络地址：主机号为全0的地址不可用</li><li>广播地址：主机号为全1的地址</li><li>回环地址：127.0.0.0</li></ul></li></ul><h4 id="ipv6">4.3.4 IPv6</h4><ul><li><p>IPv6地址由128位，16个字节组成，一般表现形式为十六进制</p></li><li><p>每个16bit的值用十六进制表示，各值之间用冒号分隔。</p><ul><li>零压缩，即一连串连续的零可以为一对冒号所取代</li><li>一个IPv6地址中，零压缩只能使用一次</li></ul></li><li><p>IPv6数据报格式</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721160309259.jpeg" alt="img" style="zoom:80%;"></p><ul><li>通信种类——8bit，区分不同数据报的类别或优先级。</li><li>流标号——20bit，“流”是互联网络上从特定源到特定终点的一系列数据报，“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有相同的流标号。</li><li>有效载荷长度——16bit</li><li>下一个首部——8bit，相当于IPv4的协议字段或可选字段</li><li>跳数限制——8bit，源站在数据报发出时即设定跳数限制</li><li>IPv6数据报的目的地址分3中基本类型地址<ul><li>单播：点对点</li><li>组播：一对多</li><li>任播：任播的目的站时一组计算机，但数据报在交付时只交付给其中一个，通常是距离最近的一个</li></ul></li></ul></li><li><p>IPv4向IPv6过渡的方法</p><ul><li>双协议栈：指一部分主机（或路由器）装有两个协议栈，一个IPv4和一个IPv6</li></ul><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721160838593.jpeg" alt><figcaption>img</figcaption></figure><ul><li>隧道技术</li></ul><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-16-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721160848879.jpeg" alt><figcaption>img</figcaption></figure></li></ul><h3 id="子网划分">4.4 子网划分</h3><h4 id="定义">4.4.1 定义</h4><p>使得多个物理网络可以共用一个网络前缀，这种做法叫作划分子网(subnetting) 即可变长子网掩码<strong>VLSM</strong>。通过子网划分可以减少地址的浪费，使得IP地址的使用更为科学。</p><h4 id="方法">4.4.2 方法</h4><p>通过修改子网掩码，起到更加精细划分网络号和主机号的作用</p><p><strong>IP 地址 = [ 网络号，子网号，主机号 ]</strong></p><p><strong>子网地址 = 子网掩码 AND IP 地址 </strong></p><p>为了反映哪些位用于子网号，采用子网掩码：网络号、子网号对应位为1，主机号对应位为0。</p><p>一般从主机号的最左边开始连续借用若干位用作子网号，位数是可变的。</p><h4 id="vlsm可变长子网掩码">4.4.3 VLSM可变长子网掩码</h4><p>为了有效的使用无类别域间路由（CIDR）和路由汇聚（route aggregation）来控制路由表的大小，它是网络管理员常用的IP寻址技术，VLSM就是其中的常用方式，可以对子网进行层次化编织，以便最有效的利用现有的地址空间。</p><ul><li>无类别域间路由CIDR：消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。 IP 地址从三级编址（使用子网掩码）又回到了两级编址。<ul><li>使用“斜线记法”： 即在IP地址后面加上一个斜线“/”，后面写上网络前缀所占的比特数，如20.5.0.0/10，还可简写为 20.5/10。</li><li>128.14.32.0/20表示的地址块共有个地址（主机号的比特数 = 32-20）。 该地址块的起始地址是 128.14.32.0。 该地址块的最小地址：128.14.32.0即 10000000.00001110.00100000.00000000 ,该地址块的最大地址：128.14.47.255 即1000 0000.0000 1110.0010 1111.1111 1111</li></ul></li><li>路由聚合：路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。<ul><li>路由表中的每个项目由“网络前缀/掩码”和“下一跳地址”组成。 在查找路由表时可能会得到不止一个匹配结果。 应当从匹配结果中选择具有最长网络前缀的路由：<strong>最长前缀匹配(longest-prefix matching)</strong>。 网络前缀越长，其地址块就越小，因而路由就越具体。</li></ul></li></ul><h3 id="网络层的路由">4.5 网络层的路由</h3><h4 id="路由的定义">4.5.1 路由的定义</h4><ul><li><p>路由是指分组从源到目的地时，决定端到端路径的网络范围的进程。路由是知道报文转发的路径信息，通过路由可以确认转发IP报文的路径。</p></li><li><p>路由是网络层最主要的工作任务</p></li></ul><h4 id="路由器">4.5.2 路由器</h4><ul><li>网络层的基本设备</li><li>用作数据转发</li><li>一个端口代表一个网段，路由器中存放着通往各个网段的表格，叫路由表<ul><li>路由表又称路由择域信息库，是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库，路由表存储着指向特定网络地址的路径</li></ul></li></ul><h4 id="网关">4.5.3 网关</h4><ul><li>网关是一个IP地址，用于不同网段之间的通信</li><li>网关又称网间连接器、协议转换器。用于两个高层协议不同的网络互联。网关既可以用于广域网互连，也可以用于局域网互连。</li></ul><h4 id="路由获取方式">4.5.4 路由获取方式</h4><ul><li>直连路由</li><li>静态路由</li><li>动态路由</li></ul><h4 id="路由的配置方式">4.5.5 路由的配置方式</h4><ul><li>静态路由<ul><li>由管理员手动配置，配置方便、对系统要求低，适用于拓扑结构简单稳定的小型网络</li><li>缺省路由： 是一种特殊的路由，当报文没有在路由表中找到匹配的具体表现项时才能使用的路由</li></ul></li><li>动态路由<ul><li>通过动态路由协议来实现不同网段的路由互通</li><li>动态路由协议自己的路由算法，能够自动适应网络拓扑结构的变化，适用于具有一定数量的三层设备的网络</li><li>动态路由协议：<ul><li>RIP路由信息协议——内部网关协议<ul><li>基于矢量的动态路由协议</li><li>适用于中小规模的网络拓扑，最大跳数为15</li><li>RIP 协议中的“距离”也称为“跳数” (hop count)，因为每经过一个路由器，跳数就加 1。从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。 RIP 允许一条路径最多只能包含 15 个路由器。</li><li>运行RIP的路由器仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li></ul></li><li>OSPF开放式最短路径优先协议——内部网关协议<ul><li>基于链路状态的协议</li><li>使用SPF算法，计算最短路径。树形协议。收敛速度比RIP更加迅速</li><li>适用于大规模的网络拓扑</li><li>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡。</li></ul></li><li>BGP——外部网关协议<ul><li>BGP是自治系统间的路由协议，自治系统之间的路由协议</li></ul></li><li>IS-IS——内部网关协议<ul><li>类似OSPF，IS-IS是基于路由划分区域，而OSPF基于接口划分区域</li></ul></li></ul></li></ul></li></ul><h3 id="ip地址转换">4.6 IP地址转换</h3><ul><li><p>VPN</p><ul><li>隧道传输</li><li>加密技术</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-20-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721204927680.jpeg" alt="img" style="zoom:80%;"></p></li><li><p>NAT（网络地址转换）</p><ul><li>基本网络地址转换（NAT） 并发访问特定外部地址存在限制；</li><li>网络地址和端口转换（NAPT） 通过对TCP和UDP端口以及IP地址的转换允许并发访问。</li></ul></li></ul><h2 id="五传输层">五、传输层</h2><h3 id="传输层概论">5.1 传输层概论</h3><h4 id="传输层的作用">5.1.1 传输层的作用</h4><ul><li><p>提供端到端的服务</p></li><li><p>传输层的作用是在通信子网提供的服务的基础上，为应用层提供有效的、合理的传输服务。使高层用户在相互通信时不必关心通信子网实现细节和具体服务质量。</p></li></ul><h4 id="端口和套接字">5.1.2 端口和套接字</h4><ol type="1"><li><p>端口</p><ul><li>端口就是传输层服务访问点 TSAP（也就是与应用进程的接口）</li><li>端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li><li>端口是应用层进程的标识，字长16bit。</li><li>分类<ul><li>熟知端口：其数值一般为 0~1023。这些端口号是TCP/IP体系确定并公布</li><li>一般端口：用来随时分配给请求通信的客户进程</li></ul></li></ul><table><thead><tr class="header"><th style="text-align: center;">端口</th><th style="text-align: center;">21（20）</th><th style="text-align: center;">23</th><th style="text-align: center;">25</th><th style="text-align: center;">53</th><th style="text-align: center;">69</th><th style="text-align: center;">80</th><th style="text-align: center;">161</th><th style="text-align: center;">443</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">协议</td><td style="text-align: center;">FTP</td><td style="text-align: center;">TELNET</td><td style="text-align: center;">SMTP</td><td style="text-align: center;">DNS</td><td style="text-align: center;">TFTP</td><td style="text-align: center;">HTTP</td><td style="text-align: center;">SNMP</td><td style="text-align: center;">HTTPS</td></tr><tr class="even"><td style="text-align: center;">中文</td><td style="text-align: center;">文件传输协议（21建立连接，20传输数据）</td><td style="text-align: center;">远程登录</td><td style="text-align: center;">电子邮件传输协议</td><td style="text-align: center;">域名系统</td><td style="text-align: center;">简单文件传输协议</td><td style="text-align: center;">超文本传输协议</td><td style="text-align: center;">简单网络管理协议</td><td style="text-align: center;">超文本传输安全协议</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">TCP</td><td style="text-align: center;">TCO</td><td style="text-align: center;">TCP</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">TCP</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></li><li><p>套接字</p><ul><li><span class="math inline">\(套接字=&lt;IP地址，端口号&gt;\)</span></li><li><span class="math inline">\(五元组 = &lt;源IP地址，源端口，目的IP地址，目的端口，传输协议&gt;\)</span></li></ul></li></ol><h3 id="传输层两个重要协议">5.2 传输层两个重要协议</h3><h4 id="tcp传输控制协议">5.2.1 TCP传输控制协议</h4><ol type="1"><li><p>TCP是TCP/IP体系中较为复杂的协议，是传输层的重要协议。</p></li><li><p>TCP数据报</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-21-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721212556466.jpeg" alt="img" style="zoom:80%;"></p><ul><li>源端口和目的端口字段（2 字节），传输层的复用和分用功能都要通过端口才能实现。</li><li>序号字段（4字节），TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段（4字节），期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li>数据偏移（4bit），指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。4字节为计算单位。</li></ul></li><li><p>主要特点</p><ul><li>是面向连接的传输层协议</li><li>提供可靠的交付服务</li><li>提供全双工通信</li><li>面向字节流</li></ul></li><li><p>窗口</p><ul><li>固定窗口</li><li>滑动窗口</li><li>用于拥塞处理和流量控制</li></ul></li><li><p>三次握手——建立连接</p></li></ol><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-21-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721210638774.jpeg" alt="img" style="zoom:80%;"></p><ol start="5" type="1"><li>四次挥手——释放连接</li></ol><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-21-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721210655738.jpeg" alt="img" style="zoom:80%;"></p><ol start="6" type="1"><li><p>保证可靠传输的三个方面</p><ul><li><p>序号确认</p><ul><li>TCP 将所要传送的整个应用层报文看成是一个个字节组成的数据流，然后对每一个字节编一个序号。 在连接建立时，双方要商定<em>初始序号</em>。 TCP 就将每一次所传送的报文段中的第一个数据字节的序号，放在TCP首部的序号字段中。</li><li>TCP 的确认是对接收到的数据的最高序号表示确认。确认号表示接收端期望下次收到的数据中的第一个数据字节的序号。</li><li>为提高效率，TCP可以累积确认，即在接收多个报文段后，一次确认。</li></ul></li><li><p>超时重传</p></li><li><p>定时器设置</p></li></ul></li><li><p>拥塞控制</p><ul><li>TCP 采用大小可变滑动窗口的方式进行流量控制。窗口大小的单位是字节。</li><li>根据接收方接收能力，通过接收窗口rwnd（receive window）可以实现端到端的流量控制，接收端将接收窗口rwnd的值放在 TCP 报文的首部中的“窗口”字段，传送给发送端。</li><li>发送窗口的取值依据拥塞窗口和接收窗口中的较小的值，即 Min［rwnd，cwnd］<ul><li>慢启动：指在TCP刚建立连接或者当网络发生拥塞超时的时候，将拥塞窗口cwnd设置成一个报文段大小，并且当cwnd≤ssthresh时，<strong>指数方式</strong>增大cwnd（即每经过一个传输轮次，cwnd加倍）。</li><li>拥塞避免：当cwnd≥ssthresh时，为避免网络发生拥塞，进入拥塞避免算法，这时候以<strong>线性方式</strong>增大cwnd（即每经过一个传输轮次，cwnd只增大一个报文段）。</li><li>快速重传：快速重传算法是指发送方如果连续收到三个重复确认的ACK，则立即重传该报文段，而不必等待重传定时器超时后再重传。</li><li>快速恢复：快速恢复算法是指当采用快速重传算法的时候，直接执行拥塞避免算法。这样可以提高传输效率。 <img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-21-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721211236106.jpeg" alt="img" style="zoom:67%;"></li></ul></li></ul></li><li><p>TCP的应用</p><ul><li>FTP，要求保证数据传输的可靠性</li><li>TELNET，要求保证字符正确传输</li><li>SMTP，POP3，要求保证邮件从发送方正确到达接收方</li><li>HTTP，要求可靠的交换超媒体信息</li></ul></li></ol><h4 id="udp用户数据报协议">5.2.2 UDP用户数据报协议</h4><ol type="1"><li>在IP数据报之上增加了一些功能，增加了复用和分用、差错检测功能</li><li>主要特点<ul><li>无连接</li><li>不可靠的服务</li><li>面向报文，没有拥塞控制</li><li>开销较小、传输效率较高</li></ul></li><li>UDP数据报</li></ol><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-21-image-20210721211912371.png" alt="image-20210721211912371" style="zoom:80%;"></p><ol start="4" type="1"><li>UDP的应用<ul><li>DNS——域名系统，为了减少协议的开销</li><li>DHCP——动态主机配置协议，需要进行报文广播</li><li>TFTP——简单文件传输协议，实现简单文件需同时向许多机器下载</li><li>SNMP——简单网络管理协议，网络上传输SNMP报文的开销小</li><li>RIP——路由选择信息协议，路由协议开销小</li><li>RTP、RTCP——实时传输协议、实时传输控制协议，因特网的实时应用</li></ul></li></ol><h2 id="六应用层">六、应用层</h2><h3 id="应用层的作用">6.1 应用层的作用</h3><p>通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应用层的内容就是具体定义通信规则。</p><h3 id="部分应用层协议与传输层协议的对应关系">6.2 部分应用层协议与传输层协议的对应关系</h3><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-21-21-07-21-21-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210721212814859.jpeg" alt="img" style="zoom:80%;"></p><h3 id="网络应用模式服务器工作模式">6.3 网络应用模式、服务器工作模式</h3><ol type="1"><li><p>以大型机为中心的应用模式 该应用模式又称为分时共享模式，也就是面向终端的多用户计算机系统（主从结构）</p></li><li><p>以服务器为中心的应用模式 该应用模式又称为资源模共享模式，向单个用户站点提供灵活的服务，但管理控制和系统维护工具的功能较弱。</p></li><li><p>客户机－服务器模式 （Client/Server, C/S） 传统的网络基本服务基本上都是基于客户机－服务器模式 如:Telnet, WWW, E-Mail, FTP等。</p><p>C/S 应用模式：应用层的许多协议都是基于客户服务器（C/S）方式。 客户端（Client）和服务器端（Server）都是指通信中所涉及的两个应用进程。 所描述的是进程之间服务和被服务的关系。客户端是服务请求方，服务器端是服务提供方。</p></li><li><p>基于Web的客户机/服务器应用模式</p></li><li><p>对等网络应用模式（Peer-to-Peer, P2P）</p></li></ol><h3 id="服务器工作方式">6.4 服务器工作方式</h3><ol type="1"><li>循环方式：只进行1个进程，按请求先后顺序依次响应</li><li>并发方式：同时运行多个进程，每个进程分别对某个特定进程做响应</li></ol><h3 id="网络基本服务">6.5 网络基本服务</h3><h4 id="dns域名系统命名系统">6.5.1 DNS（域名系统）命名系统</h4><ul><li>DNS是一个分布式数据库联机系统</li><li>采用客户端/服务器应用模式</li><li>client：从域名到IP地址的解析是由若干个域名服务器程序完成</li><li>采用层次树状结构的命名方法，为主机命名</li><li>任一连接在因特网上的主机或路由器，都有一个唯一的层次结构名字，即域名</li><li>用点号“.“ 将各级域名分开，但域层次顺序自右到左，即右侧的域最高</li><li>域名解析服务<ul><li>根域名Serve<ul><li>正向域名解析<ul><li>递归解析</li><li>重复解析</li></ul></li><li>反向域名解析</li></ul></li><li>授权域名Serve</li><li>本地域名Serve</li></ul></li></ul><h4 id="ftp文件传输协议">6.5.2 FTP（文件传输协议）</h4><ul><li>Internet的文件传输标准</li><li>允许在联网的不同主机和不同操作系统之间传输文件，并允许含不同文件的结构和字符集</li><li>面向连接的C/S服务，使用两条TCP连接来完成文件传输<ul><li>连接专用于控制（Port：21）</li><li>连接为数据连接（Port：20）</li></ul></li><li>一个FTP进程可服务多个客户进程</li><li>FTP进程分为<ul><li>主进程：负责接收客户请求，并建立从属进程</li><li>从属进程：负责处理请求，并按需可以多个从属进程</li></ul></li><li>主进程打开Port21，倾听客户的连接请求（一直打开）——控制连接</li><li>当Client发出数据传输命令式，Serve（Port：20）主动与客户建立一条数据连接——数据连接</li></ul><h4 id="dhcp动态主机配置协议">6.5.3 DHCP（动态主机配置协议）</h4><ul><li>BOOTP（引导程序协议）使用UDP协议，C/S服务模式，静态配置协议</li><li>即插即用连网</li><li>允许一台计算机加入新网可自动获取IP地址</li><li>允许用户动态使用网络资源</li><li>使用C/S服务模式<ul><li>某主机需要IP地址，向DHCP服务器发送广播报文（广播发现报文）</li><li>DHCP查找该计算机配置文件作出响应，若找不到则分配一个IP地址（提供报文）</li><li>主机只接收第一个响应</li></ul></li><li>并不是每个网络上都有DHCP服务，使每个网络中至少有一个DHCP中继代理（配置了DHCP Serve的IP），中继代理收到主机发送的广播发现报文后，以单播方式向DHCP服务器转发</li></ul><h4 id="电子邮件系统与smtp简单邮件传送协议">6.5.4 电子邮件系统与SMTP（简单邮件传送协议）</h4><ul><li><p>组成构件</p><ul><li>用户代理UA</li><li>邮件服务器</li><li>电子邮件所用协议，如SMTP、POP3（用于从目的邮件服务器上读取邮件）、MINE……</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-07-22-14-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210722143606561.jpeg" alt="img" style="zoom:60%;"></p></li><li><p>SMTP协议三个阶段</p><ul><li>建立连接</li><li>邮件传送</li><li>连接释放</li></ul></li></ul><h4 id="万维网与http">6.5.5 万维网与HTTP</h4><ul><li><p>万维网WWW</p><ul><li>用链接的方式能从因特网上的一个站点访问另一个站点</li><li>是一种多媒体超文本信息服务系统</li><li>C/S工作模式</li><li>在一个客户程序主窗口上显示出的万维网文档称为页面</li><li>组成：浏览器、Web服务器和超文本传输协调</li></ul></li><li><p>怎样标志分布在整个因特网上的万维网文档？</p><p>使用<strong>统一资源定位符 URL</strong> (Uniform Resource Locator)来标志万维网上的各种文档。使每一个文档在整个因特网的范围内具有惟一的标识符 URL。</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-07-22-14-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210722144003643.jpeg" alt="img" style="zoom:50%;"></p></li><li><p>如何实现WWW上各种超链的链接</p><p>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议 HTTP</strong> (HyperText Transfer Protocol)。</p><p>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</p></li><li><p>怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？</p><p>超文本标记语言 HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。</p></li><li><p>怎样使用户能够很方便地找到所需的信息？</p><p>为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）</p></li><li><p>万维网工作过程</p></li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-07-22-14-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210722144236408.jpeg" alt="img" style="zoom:50%;"></p><h2 id="七网络管理与网络安全">七、网络管理与网络安全</h2><h3 id="网络管理">7.1 网络管理</h3><p>网络管理系统也称网络的操作管理和维护系统</p><h4 id="网络管理的主要功能">7.1.1 网络管理的主要功能</h4><ol type="1"><li>配置管理：初始化网络，配置网络，以提供网络服务。目的是实现某个特定功能或使网络性能达到最优。</li><li>性能管理：对网络性能、资源利用率及有关通信活动进行分析，以帮助网络管理人员评价网络资源及相关通信活动的情况和效率。</li><li>故障管理（最基本）：网络管理最基本的功能，主要对网络设备和服务器故障进行检测、诊断，故障排除、维修及报告。<ol type="1"><li>计费管理：记录网络资源的使用，目的是控制和监测网络操作的费用和代价。可以估算出用户使用网络资源可能需要的费用和代价，以及已使用的资源。 计费管理是对网络资源和通信资源的使用进行计费，对用户的访问活动建立详细记录。 计费系统还具有安全管理功能。</li></ol></li><li>安全管理</li></ol><h4 id="网络管理协议一种通信标准">7.1.2 网络管理协议（一种通信标准）</h4><ol type="1"><li><p>三种</p><ul><li>基于OSI参考模型：公共管理信息服务和公共管理信息协议（CMIS/CMIP）</li><li>基于TCP/IP体系：<ul><li>简单网络管理协议SNMP</li><li>CMIP</li></ul></li></ul></li><li><p>SNMP</p><ul><li>采用管理进程-代理进程模型，C/S工作方式，管理协议在应用层上运行。</li><li>三个基本元素：管理者、代理、管理信息库（MIB）</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-22-14-07-22-14-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY1OTk2,size_16,color_FFFFFF,t_70-20210722144706754.jpeg" alt="img" style="zoom:50%;"></p><ul><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。 在网络正常工作时，SNMP 可实现统计、配置、和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>SNMP三个主要部件<ul><li>管理信息结构（SMI）：描述管理信息的标准符号。</li><li>管理信息库（MIB）：包含待管理的各种变量。MIB定义的通用化格式支持对每一个新的待管理服务定义其特定的MIB组，使厂家有标准方法以定义其专用的管理对象。</li><li>管理协议，也称 SNMP。</li></ul></li><li>SNMP 是有效的网络管理协议——使用探询（至少是周期性地）以维持对网络资源的实时监视，同时也采用陷阱机制报告特殊事件，使得 SNMP 成为一种有效的网络管理协议。 SNMP具有网络管理所要求的主要管理功能。</li></ul></li></ol><h3 id="网络安全">7.2 网络安全</h3><h4 id="计算机网络安全威胁因素">7.2.1 计算机网络安全威胁因素</h4><ol type="1"><li>截获——从网络上窃听他人的通信内容。</li><li>中断——有意中断他人在网络上的通信。</li><li>篡改——故意篡改网络上传送的报文。</li><li>伪造——伪造信息在网络上传送。</li></ol><p>截获信息的攻击称为被动攻击，更改信息和拒绝用户使用资源攻击称为主动攻击。</p><h4 id="安全目标">7.2.2 安全目标</h4><p>可靠性、可用性、保密性、完整性、不可抵抗性</p><h4 id="数据加密技术">7.2.3 数据加密技术</h4><ol type="1"><li>对称加密（加密与解密密钥相同</li><li>非对称加密RSA<ul><li>加密密钥（公开）PK</li><li>解密密钥（保密）SK</li></ul></li></ol><h2 id="八无线网络">八、无线网络</h2><ul><li>注：部分内容参考本篇文章<a href="https://wittpeng.blog.csdn.net/article/details/85267403" target="_blank" rel="noopener">CSDN【期末复习】计算机网络</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点复习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点汇总</title>
      <link href="/posts/1983612312/"/>
      <url>/posts/1983612312/</url>
      
        <content type="html"><![CDATA[<h2 id="一引论">一、引论</h2><ol type="1"><li>定义：一种系统软件</li><li>地位：裸机之上的第一层软件，是建立其他所有软件的基础。它是整个系统的控制管理中心，既管硬件，又管软件，它为其他软件提供运行环境。</li><li>基本特征：并发、共享、异步、虚拟。（最基本特征：并发、共享）</li><li>主要功能：处理机管理、存储器管理、文件管理、设备管理</li><li>发展历程：手工操作阶段、批处理阶段、分时操作系统（有人机交互）、实时操作系统（能优先处理紧急任务）</li></ol><h3 id="一些预置概念">一些预置概念</h3><ol type="1"><li><p>两种指令</p><ul><li>特权指令：不允许用户程序使用（只允许操作系统使用）。如IO指令、置中断指令</li><li>非特权指令：普通用户的运算指令</li></ul></li><li><p>两种程序</p><ul><li>内核程序：</li><li>应用程序：</li></ul></li><li><p>处理机状态</p><ul><li>用户态（目态）：CPU只能执行非特权指令</li><li>核心态（管态、内核态）：可以执行所有指令</li><li>用户态到核心态：通过中断（是硬件完成的）</li><li>核心态到用户态：特权指令psw的标注位：0用户态、1核心态</li></ul></li><li><p>原语</p></li><li><p>中断和异常</p><ul><li>内中断（异常，信号来自内部）<ul><li>自愿中断——指令中断</li><li>强迫中断——硬件中断、软件中断</li></ul></li><li>外中断（中断，信号来自外部）<ul><li>外设请求（如打印机缺纸……）</li><li>人工干预</li></ul></li></ul></li><li><p>系统调用</p><p>系统给程序员（应用程序）提供的唯一接口，可获得OS的服务。在用户态发生，核心态处理</p></li><li><p>体系结构</p><ul><li>大内核</li><li>微内核</li></ul></li></ol><h2 id="二进程调度">二、进程调度</h2><h3 id="进程管理">2.1 进程管理</h3><ol type="1"><li><p>目的</p><p>为了更好地描述和控制程序并发执行，实现操作系统的并发性和共享性</p><p>（进程是动态的，程序是静态的）</p></li><li><p>定义</p><p>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</p></li><li><p>组成</p><ul><li>进程控制块PCB：保存进程运行期间相关的数据，是进程存在的<strong>唯一标志</strong></li><li>程序段：能被进程调度到CPU的代码</li><li>数据段</li></ul></li><li><p>进程的状态：</p><ul><li>运行态</li><li>就绪态：一切资源准备完善，等待处理机调度</li><li>阻塞态</li><li>创建状态</li><li>结束状态</li></ul></li><li><p>进程的状态转换</p><ul><li>运行态-&gt;就绪态：时间片用完等</li><li>运行态-&gt;阻塞态：等待资源或事件等</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-18-22-07-18-22-07-18-22-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTAzNDk1,size_16,color_FFFFFF,t_70-20210718221929142.png"></p></li><li><p>线程</p><ul><li>引入目的：为了更好的使用多道程序并发执行，提高资源利用率和系统吞吐量</li><li>特点：是程序执行的最小单位，基本不拥有任何系统资源（调度的基本单位）‘’资源分配的基本单位还是进程）</li><li>线程属于某一个进程，并与进程内的其他线程一起共享进程的资源</li></ul></li><li><p>进程和线程的区别</p><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p></li><li><p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p></li><li><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p></li><li><p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p></li><li><p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p></li><li><p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ul></li></ol><h3 id="处理机调度">2.2 处理机调度</h3><ol type="1"><li><p>概念</p><p>是对处理机进行分配，即从就绪队列中按照算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p></li><li><p>分类</p><ul><li>高级调度（作业调度）次数少</li><li>中级调度（内存对换）次数中等，与挂起态有关</li><li>低级调度（进程调度）次数多</li></ul></li><li><p>调度方式</p><ul><li>剥夺式</li><li>非剥夺式</li></ul></li><li><p>调度准则</p><ul><li>CPU利用率</li><li>系统吞吐量</li><li>周转时间</li><li>等待时间</li><li>响应时间</li></ul></li><li><p><strong>进程调度算法</strong></p><ul><li><p>先来先服务FCFS：有利于长作业</p></li><li><p>最短作业优先算法SJF</p></li><li><p>最短剩余时间优先算法SRTF：把SJF改为抢占式</p></li><li><p>最高响应比优先算法HRN：长短作业兼顾</p><p>响应比计算<span class="math inline">\(R=1+\frac{作业等待时间}{作业处理时间}\)</span></p></li><li><p>时间片轮转算法：剥夺式调度</p></li><li><p>多级反馈队列调度算法：长短作业兼顾</p></li></ul></li></ol><h3 id="管程">2.3 管程</h3><ol type="1"><li>组成<ul><li>名称：管理进程的程序</li><li>局部于管程内部的共享结构数据说明</li><li>对该数据结构进行操作的一组过程（或函数）</li><li>共享数据设置初值</li></ul></li><li>条件变量（进程阻塞的原因）操作<ul><li>wait（正在调用管程的进程用wait插入等待队列，释放管程）</li><li>signal（唤醒一个因x条件而阻塞的进程）</li></ul></li></ol><h3 id="进程同步">2.4 进程同步</h3><ol type="1"><li><p>引入原因：协调进程之间的相互制约关系</p></li><li><p>制约关系</p><ul><li>同步：直接制约关系，访问者对资源有序访问</li><li>互斥：间接制约关系，多个进程之间共享临界资源存在的关系，一个进程进入临界区使用临界资源时，另一个进程必须等待。</li></ul></li><li><p>临界资源</p><p>一次仅允许一个进程使用的资源（例如：打印机，共享缓冲区，共享变量，公共队列……）</p></li><li><p>临界区</p><p>指进程中涉及访问临界资源的那个程序段</p></li><li><p>临界区互斥</p><ul><li>原则<ul><li>有空让进</li><li>无空等待</li><li>多中择一</li><li>有限等待</li><li>让权等待：如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ul></li><li>基本方法<ul><li>信号量-&gt;PV操作<ul><li>wait（占有资源）P操作</li><li>signal（释放资源）V操作</li></ul></li></ul></li></ul></li></ol><h3 id="死锁">2.5 死锁</h3><ol type="1"><li>m个系统资源总数，n个进程数，k个每个进程最大需求量则：<span class="math inline">\(m&gt;=n*(k-1)+1\)</span></li><li>产生原因：非剥夺资源的竞争和进程的不恰当推进顺序（与饥饿不同）</li><li>定义：多个进程因竞争资源而造成的一种僵局，如果没有外力，这些进程将无法推进</li><li>四个必要条件：<ul><li>互斥使用（资源独占）</li><li>不可强占（不可剥夺）：该资源只能由本进程释放</li><li>请求和保持（部分分配，占有申请）：进程已经保持一个资源，但提出新的资源请求</li><li>循环等待</li></ul></li><li>解决方法：<ul><li>预防死锁<ul><li>破坏不可剥夺条件：在允许进程动态申请资源的前提下，一个进程在申请新的资源不能得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请</li><li>破坏请求和保持条件：要求每个进程在运行前一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配</li><li>破坏循环等待条件：采用资源有序分配法，把系统中所有资源编号，进程在申请操作资源时必须严格按照资源编号的递增次序进行，否则操作系统不给予分配</li></ul></li><li>避免死锁<ul><li>安全状态（寻找安全序列）</li><li>银行家算法（动态方法）</li></ul></li><li>检测死锁<ul><li>进程资源分配图+死锁定理</li></ul></li><li>解除死锁<ul><li>资源剥夺法</li><li>撤销进程法</li><li>进程回退法</li></ul></li></ul></li></ol><h2 id="三内存管理">三、内存管理</h2><h3 id="功能">3.1 功能</h3><ol type="1"><li>内存空间的分配与回收</li><li>地址转换/地址重定位/地址映射：逻辑地址（相对地址、虚拟地址）转换为物理地址（绝对地址）</li><li>内存空间的扩充：虚拟内存的应用</li><li>存储保护：防止内存地址越界</li></ol><h3 id="装入模块放入内存方式">3.2 装入模块放入内存方式</h3><ol type="1"><li>绝对装入：适合单道程序</li><li>可重定位装入：静态重定位，适合多道程序</li><li>动态运行时装入：动态重定位</li></ol><h3 id="内存保护方式">3.3 内存保护方式</h3><ol type="1"><li>在CPU中设施一对上下寄存器</li><li>采用重定位寄存器+界地址寄存器</li></ol><h3 id="扩充内存">3.4 扩充内存</h3><ol type="1"><li>多道程序环境下<ul><li>覆盖</li><li>交换：中级调度技术</li></ul></li><li>虚拟内存管理<ul><li>局部性原理<ul><li>空间局部性</li><li>时间局部性</li></ul></li><li>特征<ul><li>多次性</li><li>对换性</li><li>虚拟性</li></ul></li><li>管理内存方式<ul><li>请求分页管理方式<ul><li>新增功能<ul><li>请求调页功能</li><li>页面置换功能<ul><li>最佳置换算法</li><li>先进先出算法：出现Belady异常</li><li>最近最久未使用算法</li><li>时钟置换算法：淘汰最近未使用的</li><li>改进时钟算法：最先淘汰被修改且没有访问的</li></ul></li><li>页面分配策略<ul><li>固定分配局部置换：产生内部碎片</li><li>可变分配全局置换：产生外部碎片</li><li>可变分配局部置换</li></ul></li><li>调入页面时机<ul><li>预调页策略</li><li>请求调页策略</li></ul></li></ul></li><li>异常</li></ul></li><li>请求分段管理方式</li></ul></li><li>最大：不超过计算机的地址位数</li></ul></li></ol><h3 id="管理内存的方式">3.5 管理内存的方式</h3><ol type="1"><li>连续分配方式<ul><li>单一连续分配</li><li>固定分区分配<ul><li>产生内部碎片、无外部碎片</li></ul></li><li>动态分区分配<ul><li>产生外部碎片</li><li><strong>分配算法</strong>：首次适应法、循环首次适应法、最佳适应法、最坏适应法、邻近适应法</li></ul></li></ul></li><li>离散分配方式<ul><li>分页存储管理方式<ul><li>单级分页<ul><li>类似固定分区技术，产生内部碎片</li><li>逻辑结构分页号+页内偏移量</li><li>引入快表，加速地址变换的速度</li></ul></li><li>二级分页</li></ul></li><li>分段存储管理方式<ul><li>分段管理的地址空间是二维的</li></ul></li><li>段页式存储管理方式</li></ul></li></ol><h2 id="四文件管理">四、文件管理</h2><h3 id="文件">4.1 文件</h3><ol type="1"><li><p>文件的组成：文件体+文件说明</p></li><li><p>文件的逻辑结构：</p><ul><li>记录式文件</li><li>流文件</li></ul></li><li><p>文件的存取方法：</p><ul><li>顺序存取</li><li>直接存取</li><li>索引存取</li></ul></li><li><p>文件的物理结构</p><ul><li>连续文件</li><li>串联文件</li><li>索引文件</li></ul></li><li><p>文件的存储设备</p><ul><li>顺序存储设备</li><li>直接存储设备</li></ul></li></ol><h3 id="文件目录结构">4.2 文件目录结构</h3><ol type="1"><li>数据结构：<ul><li>文件控制块<ul><li>文件名</li><li>物理地址</li></ul></li><li>索引节点</li></ul></li><li>操作：搜索、创建、删除、显示目录、修改目录</li><li>结构：<ul><li>单级目录结构</li><li>二级目录结构</li><li>树形目录结构</li><li>无环图目录结构</li></ul></li></ol><h3 id="文件共享">4.3 文件共享</h3><ol type="1"><li>基于索引节点的共享方式（硬链接）：链接到多个目录中</li><li>基于符号链实现文献共享（软链接）：指存放路径link</li></ol><h3 id="文件保护">4.4 文件保护</h3><ol type="1"><li>访问类型：读写执行添加</li><li>访问控制：控制用户身份</li><li>口令密码</li></ol><h3 id="文件系统层次结构">4.5 文件系统层次结构</h3><ol type="1"><li>用户调用接口</li><li>文件目录系统</li><li>存取控制验证模块</li><li>逻辑文件系统与文件信息缓冲区</li><li>物理文件系统</li><li>设备管理程序模型</li></ol><h3 id="目录实现">4.6 目录实现</h3><ol type="1"><li>线性列表</li><li>哈希表</li></ol><h3 id="文件分配方式">4.7 文件分配方式</h3><ol type="1"><li>连续分配</li><li>链接分配</li><li>索引分配</li></ol><h3 id="文件存储空间管理">4.8 文件存储空间管理</h3><ol type="1"><li>初始化：目录区、文件区</li><li>管理方法：<ul><li>空闲表法</li><li>空闲链表法</li><li>位示图法</li></ul></li></ol><h3 id="磁盘">4.9 磁盘</h3><ol type="1"><li>磁盘地址：<strong>柱面号x盘面号x扇区号</strong></li><li>读写操作时间：寻找时间、延迟时间、传输时间</li><li><strong>磁盘调度算法</strong><ul><li>先来先服务FCFS</li><li>最短寻找时间优先SSTF：存在“饥饿”现象</li><li>扫描算法/电梯算法SCAN</li><li>循环扫描算法CSCAN</li></ul></li><li>磁盘管理<ul><li>磁盘初始化</li><li>引导块</li><li>坏块</li></ul></li><li>提高磁盘I/O速度的方法<ul><li>提前读</li><li>延迟写</li><li>虚拟盘（RAM盘）</li></ul></li></ol><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-18-22-07-18-21-image-20210718211455600-20210718221946316.png"></p><h2 id="五io外设管理">五、IO外设管理</h2><h3 id="分类">5.1 分类</h3><ol type="1"><li>块设备：如磁盘……</li><li>字符设备：如打印机……</li></ol><h3 id="io控制方式">5.2 I/O控制方式</h3><ol type="1"><li>程序直接控制：没有中断机制，是忙查询；造成CPU资源浪费</li><li>中断驱动方式：字节；外设做好了再呼唤CPU；实现CPU和设备并行</li><li>DMA方式：数据块 ；不经过CPU；内存和设备之间建立了一条数据通路</li><li>通道控制方式：一种I/O专用处理器；效率比DMA高</li></ol><h3 id="io子系统层次结构">5.3 I/O子系统层次结构</h3><ol type="1"><li>用户层IO软件</li><li>设备独立性软件</li><li>设备驱动程序</li><li>中断处理程序</li><li>硬件设备</li></ol><h3 id="io管理内容">5.4 I/O管理内容</h3><ol type="1"><li>状态跟踪</li><li>设备存取</li><li>设备分配</li><li>设备控制</li></ol><h3 id="io核心子系统">5.5 I/O核心子系统</h3><ol type="1"><li><p>服务</p><ul><li>IO调度</li><li>缓冲与高速缓存</li><li>设备分配与回收</li><li>假脱机</li><li>设备保护与差错处理</li></ul></li><li><p>高速缓存+缓冲区</p><ul><li>高速缓存</li><li>缓冲区：单缓冲、双缓冲、循环缓冲、缓冲池</li></ul></li><li><p>设备分配时数据结构</p><ul><li>设备控制表DCT</li><li>控制器控制表COCT</li><li>通道控制表CHCT</li><li>系统设备表SDT</li></ul></li><li><p>设备分配步骤</p><ul><li>分配设备 SDT找DCT</li><li>分配控制器 COCT</li><li>分配通道 CHCT</li></ul></li><li><p>设备分配算法</p><ul><li>先来先服务算法</li><li>优先级高者优先</li></ul></li><li><p>SPOOLing系统</p><ul><li><p>定义：SPOOLing系统既不同于脱机方式，也不同于直接藕合方式，SPOOLing技术实际上是一种外围设备同时联机操作技术，又称为排队转储技术。它在输入和输出之间增加了“输入井”和“输出井”的排队转储环节，以消除用户的“联机”等待时间。在系统输入模块收到作业输入请求信号后，输入管理模块中的读过程负责将信息从输入装置中读入输入井缓冲区。当缓冲区满时，由写过程将信息从缓冲区写到外存的输入井中，读过程和写过程反复循环，直到一个作业输入完毕。当读过程读到一个硬件结束标志之后，系统再次驱动写过程把最后一批信息写入外存输入井并调用中断处理程序结束该次输入。然后，系统为该作业建立作业控制块，从而使输入井中的作业进入作业等待队列，等待作业调度程序选中后进入内存运行。系统在管理输入井过程中可以“不断”读入输入的作业，直到输入结束或输入井满而暂停。</p></li><li><p>组成</p><ul><li>输入井和输出井：在磁盘中</li><li>输入缓冲区和输出缓冲区：在内存中</li><li>输入进程和输出进程</li></ul><p>从输入井读取信息，作业执行结果暂存输出井</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-18-22-07-18-22-zHeHYXn3OAFvwoGevOfJJAylo8llvS8W_YJX6LP3yp2PP_lJy-4vs-5qPdReqM-JHYAFf6TD4N_WtjpGCUAyljrgawg3UZ7idXWsSEgKI1VKO0yLI6-OI4AHwIY-20210718221946340.jpeg"></p></li><li><p>特点</p><ul><li>提高了IO速度</li><li>设备不被任何进程独占</li><li>实现了虚拟设备功能</li></ul></li></ul></li></ol><h2 id="六大题涉及知识点">六、大题涉及知识点</h2><ol type="1"><li><p>信号量、PV操作</p><ul><li>机票问题</li><li>生产者——消费者问题</li><li>读者和写者问题</li><li>理发师问题</li></ul></li><li><p>银行家算法</p></li><li><p>进程调度算法</p></li><li><p>页面置换算法</p><ul><li>最佳置换算法OPT：选择永不使用的或在最长时间内不再被访问的页面进行置换</li><li>先进先出置换算法FIFO：选择最炫进入内存的页面进行置换</li><li>最近最久未使用置换算法LRU：选择最近一段时间内最长时间没有被访问过的页面进行置换</li><li>时钟置换算法/最近未使用置换算法Clock/NRU：</li><li>最少使用置换算法LFU：把当前为止被访问次数最少的页面淘汰（设置访问计数器）</li></ul></li><li><p>逻辑地址转换物理地址</p><ul><li><p>先来先服务FCFS：有利于长作业</p></li><li><p>最短作业优先算法SJF</p></li><li><p>最短剩余时间优先算法SRTF：把SJF改为抢占式</p></li><li><p>最高响应比优先算法HRN：长短作业兼顾</p><p>响应比计算<span class="math inline">\(R=1+\frac{作业等待时间}{作业处理时间}\)</span></p></li><li><p>时间片轮转算法：剥夺式调度</p></li><li><p>多级反馈队列调度算法：长短作业兼顾</p></li></ul></li><li><p>磁盘驱动臂调度算法</p><ul><li><p>先来先服务FCFS</p></li><li><p>最短寻找时间优先SSTF：存在“饥饿”现象</p></li><li><p>扫描算法/电梯算法SCAN</p></li><li><p>循环扫描算法CSCAN</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 知识点复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于长沙</title>
      <link href="/posts/2946656121/"/>
      <url>/posts/2946656121/</url>
      
        <content type="html"><![CDATA[<figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/08-04-23-IMG_2741.JPG" alt><figcaption>IMG_2741</figcaption></figure><h3 id="一出行准备">一、出行准备🎒</h3><h4 id="行李备忘">1.1 行李备忘🧳</h4><ul class="task-list"><li><input type="checkbox" disabled checked>洗漱用品</li><li><input type="checkbox" disabled checked>防晒霜</li><li><input type="checkbox" disabled checked>伞</li><li><input type="checkbox" disabled checked>护肤品</li><li><input type="checkbox" disabled checked>充电器</li><li><input type="checkbox" disabled checked>充电宝</li><li><input type="checkbox" disabled checked>洗牙器！！</li><li><input type="checkbox" disabled checked>学生证！！！</li></ul><h4 id="关于交通">1.2 关于交通</h4><ul><li>厦门-长沙 ✈️ 往返</li><li>长沙地铁、掌上公交APP</li><li>“湖南省居民健康卡”申请健康卡</li></ul><h4 id="关于吃喝">1.3 关于吃喝</h4><ul><li>【奶茶 🥤】<ul><li>茶颜悦色（我要把所有的喝一遍，注册的时候把去的那天作为生日hhh<ul><li>（十米一家茶颜悦色 不要怕喝不到 但是基本上人都很多 外卖不多 都线下排队买</li><li>幽兰拿铁</li><li>蔓越阑珊</li><li>人间烟火</li></ul></li><li>MAMAcha<ul><li>莓莓茶果乐</li></ul></li></ul></li><li>【小龙虾 🦞】<ul><li>天宝兄弟</li><li>小浣熊</li></ul></li><li>【嗦粉】<ul><li>肆姐粉店（坡子街）</li><li>夏记粉店</li></ul></li><li>【湘菜】<ul><li>炊烟时代！！</li><li>壹盏灯</li><li>费大厨辣椒炒肉（没有炊烟时代好吃</li></ul></li><li>【小吃】<ul><li>黑色经典臭豆腐</li><li>邵福记梅菜扣肉饼</li><li>金记糖油坨坨</li><li>吴酥生宫廷酥饼</li></ul></li></ul><h4 id="关于住宿">1.4 关于住宿</h4><ul><li>考虑因素<ul><li>近地铁站</li><li>近市中心</li></ul></li><li>最后定了 <strong>觅恋芳舍酒店（长沙五一广场地铁站店）</strong>的LOFT房 🏠</li><li>体验<ul><li>整体干净整洁</li><li>有窗户</li><li>厕所有些不太满意</li><li>其他都还可以</li><li>没有拍房间 但是基本跟携程上的照片差不多</li></ul></li></ul><h3 id="二day-1-8.8-周六">二、Day 1 8.8 周六</h3><h4 id="抵达">2.1 抵达</h4><ul><li><p>厦门 ✈️ 长沙 16:40落地</p></li><li><p>酒店交通</p><ul><li>机场二楼 磁悬浮列车 20 💰</li><li>地铁二号线——五一广场</li><li>⏰ 耗时1.5小时左右</li></ul></li><li><p>茶颜悦色初体验</p><ul><li>关注公众号</li><li>进去小程序注册一下会员</li><li>料想到两个人可能会喝很多 就提前冲了200¥ 然后送了30¥ 🤭</li><li>注册会员的时候 生日设置去的那几天 就可以白嫖一杯（薅羊毛 🤚</li></ul><figure class="half"><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_4851.PNG" alt="IMG_4851" style="zoom:30%;float:left"> <img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-09-IMG_4857_%E5%89%AF%E6%9C%AC.jpg" alt="IMG_4857_副本" style="zoom:13.2%;display:inline"></p></figure></li></ul><h4 id="坡子街">2.2 坡子街</h4><ul><li><p>解决晚饭</p><ul><li>酒店在五一广场这，走路到坡子街什么的都特别近！</li><li>肆姐粉店（坡子街）</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-09-IMG_4865.jpg" alt="IMG_4865" style="height:230px;display:inline-block; align:left"></p></li></ul><h4 id="文和友打卡">2.3 文和友打卡</h4><ul><li>吃完嗦粉在街边吃了<strong>黑色经典臭豆腐</strong></li><li>时间还是很充裕，就直接步行到海信广场去看超级文和友了</li><li>网上很火的长沙标识的墙就在下楼后的出口</li></ul><figure class="third"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_4870.JPG" alt="IMG_4870" style="height:230px;display:inline-block; margin:0px"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_8569.jpg" alt="IMG_4870" style="height:230px;display:inline-block; margin:0px"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_8556.jpg" alt="IMG_4870" style="height:230px;display:inline-block; margin: 0px"></figure><h4 id="吃夜宵">2.4 吃夜宵</h4><ul><li><p>小浣熊-&gt;小龙虾！</p></li><li><p>一定一定要提前在小程序预约</p><figure class="half"><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-09-IMG_4894.jpg" alt="IMG_4894" style="zoom:10%;display:inline-block;"> <img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_4895_副本.jpg" alt="IMG_48595_副本" style="zoom:10%;display:inline-block;%"></p></figure></li></ul><h3 id="三day-2-8.9-周日">三、Day 2 8.9 周日</h3><h4 id="ifs国金中心7楼打卡">3.1 IFS国金中心7楼打卡</h4><ul><li>这个地方就很离谱。。。</li><li>如果是在旅游旺季去的话，劝退</li><li>去看两眼就好了 旅游旺季排队拍照简直窒息 🥵</li><li>大热天大早上起来排了2小时 拍照15分钟 📷</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_8580.jpg" alt="IMG_4894" style="height:400"></p><h4 id="午饭打卡炊烟时代">3.2 午饭打卡炊烟时代</h4><p>出ifs附近就有一家，每一家店都会有大喇叭 📣 一直在循环他们的广告 “传销美食”哈哈哈哈哈</p><p>取号会给一个小票 小票上的推荐菜品真的还不错 👍 两个人三道菜很刚好</p><figure class="third"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_4956_副本.jpg" alt="IMG_4956_副本" style="height:230px;display:inline-block; margin:0px"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_4964_副本.jpg" alt="IMG_4964_副本" style="height:230px;display:inline-block; margin:0px"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_4961.jpg" alt="IMG_4961" style="height:230px;display:inline-block; margin: 0px"></figure><h4 id="谢子龙影像艺术馆">3.3 谢子龙影像艺术馆</h4><ul><li>提前预约</li><li>一层免费 二层55¥</li><li>公交 🚌 26快线</li></ul><h4 id="李自健美术馆">3.4 李自健美术馆</h4><ul><li>周一闭馆</li><li>提前预约 免费 🎫</li></ul><p><strong>关于美术馆该不该去？</strong></p><p>个人认为，如果来的天数比较多可以来看一下，虽然东西不多，和其他美术馆类似，但也是个好地方</p><p>不过夏天来真的太热了 😭 会窒息 照都不想拍的那种</p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_8621.jpg" alt><figcaption>IMG_8621</figcaption></figure><h4 id="万家丽购物广场28楼天台停机坪打卡">3.5 万家丽购物广场28楼天台停机坪打卡</h4><ul><li>这个地方真的是太赞了 太绝了 👍 吹爆！宇宙中心！</li><li>可以俯瞰整个长沙 白天和晚上都很不错</li><li>如果天气好的话拍起来真的超好看的！！</li><li>有四个角可以上去，电梯可能要找一下，最好提前在小红书或者其他平台之类的找要上的电梯位置</li><li>上电梯出来就会被震撼到 上面的装潢跟其他地方的装潢不一样</li><li>建筑的很有中国特色 一出门就是被大金黄闪瞎眼 看起来又贵又伟大</li></ul><p><strong>科普万家丽的福缘文化</strong></p><p>万家丽在世界上最大的空中机场——万家丽盘古福缘机场之中，花费巨资打造了盘古开天、华胥践雷、皇羲神圣、女娲造人、玉皇大帝、唐僧西天取经、嫦娥奔月、如来佛祖八个大型铜像壁画群。</p><p>好像忘记拍建筑群的照片了…… 只有拍远眺视角的长沙！大家一定要去感受一番土豪气息</p><h3 id="img_8663四day-3-8.10-周一"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-10-IMG_8663.jpg" alt="IMG_8663">四、Day 3 8.10 周一</h3><h4 id="岳麓山">4.1 岳麓山</h4><ul><li>提前预约 免费 🎫</li><li>地铁 🚇 2号线 榕湾镇 3号口出</li><li>上山索道15💰 学生票，下山滑道35 💰</li><li>南门进-&gt;走路到岳麓书院和爱晚亭-&gt;坐观光车/走路到山顶-&gt;休息一下（4点前结束）-&gt;走五分钟，到滑道处下-&gt;滑道下到东门，地铁 🚇 四号线</li><li>（这边真正实施起来踩雷了 那天不知道怎么了 磨蹭的比较晚出门 好像是下雨了 然后去得晚 到上面的时候滑道就没了……</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-12-IMG_8732.jpg" alt="IMG_8732" style="zoom:67%;"></p><h4 id="橘子洲">4.2 橘子洲</h4><ul><li>地铁 🚇 2号线橘子洲 1号口出</li><li>还是坐观光车吧 学生票 10¥（一定要做观光车 直接去最后看雕像 根本走不动……</li><li>别用轻颜对着雕像拍照或者把妆容去掉 哈哈哈哈哈哈哈 不然毛爷爷的面部也会被识别到然后上妆了</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-12-IMG_8707.jpg" alt="IMG_8707" style="zoom:67%;"></p><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-13-IMG_8736.JPG" alt><figcaption>IMG_8736</figcaption></figure><figure class="half"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-13-IMG_5250.jpg" alt="IMG_4894" style="zoom:100%;display:inline-block;"></figure><p>杜甫江阁那边那条路黄昏 🌆 挺棒的，晚上一般都是去几个有名的街逛，都靠的很近，街头经常会碰到有人在路边唱歌，都还蛮有趣的。</p><h3 id="五day-4-8.11-周二">五、Day 4 8.11 周二</h3><h4 id="湖南省博物馆">5.1 湖南省博物馆</h4><ul><li>公交 🚌 3、113、136……</li><li>提前3天到公众号预约！！🎫 可能正常时间去约比较约不到 我们好像凌晨的时候约的hhhhh 反正要记得</li><li>就正常的旅游景点，可以去看看，了解一下那边的文化</li><li>比较吸睛的应该是 去参观千年女尸了 这个是最后才看到的 整个游览过程就是按着挖墓顺序来的</li></ul><h4 id="梅溪湖国际文化艺术中心">5.2 梅溪湖国际文化艺术中心</h4><p><strong>「流动的永恒」</strong></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-11-IMG_8859.jpg" alt="IMG_8859" style="zoom:50%;"></p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-11-IMG_8822.jpg" alt="IMG_8822" style="zoom:50%;"></p><ul><li><p>地铁 🚇 2号线 文化艺术中心</p></li><li><p>设计师是扎哈 太爱她的作品了 每一个都令人十分惊艳</p></li><li><p>设计稿就已经不可思议了 最后落地更令人不可思议</p><p><strong>「没有曲线，就没有未来。我觉得美学中最重要的不是对称，而是动感。」</strong></p><p>立下flag 下次要进去里面探索 内外都很震撼</p></li></ul><figure class="half"><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-11-IMG_8843.JPG" alt="IMG_4851" style="zoom:10%;float:left"> <img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-11-IMG_8854.jpg" alt="IMG_4857_副本" style="zoom:11%;"></figure><h3 id="六-day-5-8.12-周三">六、 Day 5 8.12 周三</h3><h4 id="返程">6.1 返程</h4><ul><li><p>提前买了茶颜悦色、黑色经典臭豆腐的伴手礼</p><ul><li>黑色经典臭豆腐好吃！ 在网上也可以买</li></ul></li><li><p>长沙 ✈️ 厦门</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/11-06-13-IMG_7774.JPG" alt="IMG_7774" style="zoom:50%;"></p></li></ul><h3 id="我们一定会再相见的">我们一定会再相见的。</h3>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Trip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于南京</title>
      <link href="/posts/1889035989/"/>
      <url>/posts/1889035989/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-01-07-09-01-07-09-01-54CB8E07-1352-46D8-997C-EA76E48110A3.jpeg" alt="image-20200709012402620" style="zoom:30%;"></p><h2 id="一区域划分及地铁路线分布">一、区域划分及地铁路线分布</h2><p>路线查看App：Metroman</p><p>公共交通付费方式：支付宝扫码（南京地铁电子卡、金陵通乘车卡）</p><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-01-FC01FCB1-9ABD-4A6E-83DE-42CB11AFC43B.jpeg" style="zoom:50%;"></p><h2 id="二旅游小tips">二、旅游小Tips</h2><h3 id="关于住宿">2.1 关于住宿</h3><ul><li>最好选择靠近地铁站的地方入住</li><li>综合经济能力，尽量选择靠近市区的地方</li></ul><h3 id="关于交通">2.2 关于交通</h3><ul><li>一般都是地铁，可以提前规划按照地铁线路来安排行程（超方便</li><li>⚠️注意地铁的运营时间，太晚就停运只能打车 <a href="http://nj.bendibao.com/ditie/time.shtml" target="_blank" rel="noopener">查看运营时间</a></li><li>根据目的地选择路线，一般用高德地图都没有坑</li></ul><h3 id="关于吃喝">2.3 关于吃喝</h3><ul><li>特色的餐厅or小吃一般都会偏甜</li><li>不知道吃啥，小红书搜出来的一般是没有坑的，基本都在新街口附近</li><li>一般都要提前排号，饭点排队人超多</li></ul><h2 id="三热门打卡地点">三、热门打卡地点</h2><h3 id="南京博物院">3.1 南京博物院</h3><ul><li>门票🎫免费，提前预约（微信小程序：南京博物院）</li><li>地铁站：二号线·明故宫站 一号出口（还需要走几分钟的路）</li><li>游玩时长：2～3h （没有把所有馆都逛一遍，去了历史馆、数字馆、艺术馆、民国馆</li><li>tips：<ul><li>一定要提前预约</li><li>提前去排队，节假日的时候队超级长</li><li>一定要带身份证</li><li>自行备水</li></ul></li></ul><h3 id="明孝陵">3.2 明孝陵</h3><p>一个很大景区，就选择性的去了几个点而已</p><h4 id="中山陵">3.3 中山陵</h4><ul><li>不需要门票，提前预约即可</li><li>地铁站：二号线·钟灵街</li><li>tips：<ul><li>建议早上去，夏天中午太热</li><li>记得备水</li><li>不喜欢爬山的建议放弃，有超多楼梯，然后上去看5分钟而已就下来了</li><li>不过在最上面的视野超棒的</li><li>如果要去美龄宫、音乐台等其他景点，买个观光车的票，否则会累死</li></ul></li></ul><h4 id="美龄宫">3.4 美龄宫</h4><ul><li>需要购买门票🎫</li><li>逛完中山陵即可，可以买联票，顺便去音乐台</li><li>民国别墅，仅是参观</li></ul><h4 id="音乐台">3.5 音乐台</h4><ul><li>需要购买门票🎫</li><li>极限挑战取景过，就是张艺兴怕尖嘴动物那一期</li><li>有很多鸽子</li><li>暂时没去过，我看过学姐发图，好像还不错，mark了</li></ul><h4 id="梅花山">3.6 梅花山</h4><ul><li>需要购买门票🎫，有学生票</li><li>地铁站：二号线·苜蓿园</li><li>具有季节性，最好梅花盛开的季节前往</li></ul><h3 id="老门东">3.7 老门东</h3><ul><li>不需要门票</li><li>地铁站：三号线·武定门</li><li>个人觉得比夫子庙好，也可以先去夫子庙再到老门东，两处挨着</li><li>游玩时长：1～2h</li><li>tips：<ul><li>小姐姐可以穿汉服拍照📷</li><li>尽量选择在老门东吃东西，夫子庙有点是骗游客的</li></ul></li><li>美食街店铺亲测<ul><li>小郑酥烧饼：梅干菜烧饼</li><li>蒋有记牛肉锅贴：牛肉锅贴、小馄饨</li><li>鸡鸣汤包：xx汤包、小馄饨</li><li>沈记臭豆腐</li><li>蓝老大糖藕店（甜）</li></ul></li><li>老南京 又见炊烟·柴火馄饨：三条营10号，要仔细找，在小巷子里面，老爷爷老奶奶开了几十年，门店很旧，充满时代感</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-17-IMG_3042.JPG" alt="IMG_3042" style="zoom:80%;"></p><h3 id="鸡鸣寺">3.8 鸡鸣寺</h3><ul><li>需要购买门票🎫，无学生优惠，有点坑（现场只能用纸币购买</li><li>地铁站：三号线/四号线·鸡鸣寺站</li><li>据说求姻缘很灵，大家快冲</li></ul><h3 id="明城墙">3.9 明城墙</h3><ul><li>需要购买门票</li><li>在鸡鸣寺附近，在可以绕着城墙走，环着玄武湖</li><li>下来没有其他安排，可以在玄武湖划船hhh</li></ul><h3 id="五台山先锋书店总店">3.10 五台山先锋书店总店</h3><ul><li>地铁站：一号线·珠江路（下地铁还要走蛮久的路，建议打车or共享单车</li><li>拍照打卡，寄明信片</li></ul><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-17-IMG_2452.JPG" alt><figcaption>IMG_2452</figcaption></figure><h3 id="关于新街口">3.11 关于新街口</h3><ul><li>各种品牌专柜，门店……（每次进去都剁手</li><li>吃喝门店<ul><li>南京大牌档<ul><li>美龄粥</li><li>烤鸭包</li><li>江米扣肉</li><li>地锅小公鸡</li><li>招牌咸水鸭</li><li>蟹黄包</li><li>……</li></ul></li><li>桂满陇</li><li>明发茶餐厅</li><li>点都德</li><li>蛋魂汉堡</li><li>小杨生煎</li><li>首尔大排档</li><li>西木栗子（仙豆糕超好吃</li><li>泸溪河</li><li>喜茶、乐乐茶、奈雪的茶</li><li>……（待打卡</li></ul></li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-20-07-09-17-07-09-16-IMG_4293.JPEG" alt="IMG_4293" style="zoom:200%;"></p><h2 id="四小众打卡地点">四、小众打卡地点</h2><blockquote><p>上述场景在节假日人都是爆满的，以下是中秋节及国庆节和朋友去的比较小众冷门的地方，亲测不拥挤，非照骗</p></blockquote><h3 id="市区高校">4.1 市区高校</h3><h4 id="南京大学鼓楼校区">4.1.1 南京大学·鼓楼校区</h4><ul><li>地铁站：鼓楼站或珠江路站都可以，都要走一段路</li><li>进出自由，校内很静谧</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-19-IMG_2188.jpg" alt="IMG_2188" style="zoom:100%;"></p><h4 id="东南大学四牌楼校区">4.1.2 东南大学·四牌楼校区</h4><ul><li>地铁站：鸡鸣寺站（离鸡鸣寺很近，可以安排进去，骑个单车很快就到了</li><li>超喜欢这条中央大道的</li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-19-Snapseed.jpg" alt="Snapseed" style="zoom:50%;"></p><h3 id="保利大剧院南京眼">4.2 保利大剧院&amp;南京眼</h3><ul><li>地铁站：二号线·元通站（下地铁打车/共享单车到保利大剧院</li><li>可以提前看有没有想看的音乐剧或音乐会在剧院巡演可以考虑看看</li><li>不进去也可以只是拍照逛逛 建筑真超棒👍</li><li>下午到的话，可以顺着太阳下山拍光影类照片，然后天黑了可以去南京眼走走（附近暂时不知道有什么吃的</li><li>tips<ul><li>个人认为这边交通不是很方便，最好打车到地铁站之类的</li><li>中午吃多一点，那边好像没啥吃的</li></ul></li></ul><figure><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-19-IMG_4302.JPG" alt><figcaption>IMG_4302</figcaption></figure><h3 id="中山码头浦口火车站">4.3 中山码头&amp;浦口火车站</h3><ul><li>交通：地铁二号线·大行宫站➡️转31路公交到中山码头</li><li>中山码头乘船过江到浦口码头，刷支付宝公交码即可</li><li>浦口老区感觉还是很有老南京的气息，保留民国建筑，据说是朱自清《背影》经典对话出自于浦口火车站，还是《情深深雨濛濛》的取景地</li><li>由于不是很熟悉，所以我们在下码头对面的火车站长廊找了一个大爷用小破车载我们去三个点采景（来回三人120¥</li><li>历史感超级浓，大爷还跟我们介绍历史，都挺老旧了</li><li>tips：<ul><li>最好带个花露水or无比滴，蚊子多</li><li>吃啥我也不太记得，我记得我们傍晚回中山码头打车去南京长江大桥溜了一圈，发现过了游客观赏的时间，就去吃海底捞了👍</li></ul></li></ul><p><img src="https://zero-pic-bed.oss-cn-shanghai.aliyuncs.com/uPic/07-09-20-07-09-20-3CAB4AD5-A7E7-4181-AAC4-3EA79319DDD8.JPEG" alt="3CAB4AD5-A7E7-4181-AAC4-3EA79319DDD8" style="zoom:200%;"></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Trip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识微服务</title>
      <link href="/posts/1820613907/"/>
      <url>/posts/1820613907/</url>
      
        <content type="html"><![CDATA[<h2 id="初识微服务">初识微服务</h2><h3 id="什么是微服务">什么是微服务</h3><h4 id="定义">定义</h4><ul><li>将原本独立的系统拆分成多个小型服务</li><li>这些小型服务各自独立（各自维护自身的数据存储，业务开发，自动化测试以及独立部署机制独立扩展）</li><li>服务之间通过基于HTTP的RESTful API进行通信协作</li><li>更为准确的为每一个服务评估性能容量</li><li>轻量级的通信协作</li><li>可以用不同语言来编写</li></ul><h3 id="存在的挑战">存在的挑战</h3><ul><li>运维人员需要维护的进程数量增加</li><li>接口要保持一致性，原本单体应用中的代码依赖变成了服务之间的通信依赖</li><li>分布式的复杂性，需要考虑诸多因素 如网络延时、分布式事务、异步消息...</li></ul><h3 id="九大特性">九大特性</h3><h4 id="服务组件化">服务组件化</h4><ul><li>一种进程外的组件</li><li>通过HTTP等通信协议进行协作</li></ul><h4 id="按业务组织团队">按业务组织团队</h4><ul><li>按照业务线的方式进行拆分</li><li>有效减少服务内部修改所产生的内耗</li><li>团队边界更为清晰</li></ul><h4 id="做产品的态度">做“产品”的态度</h4><ul><li>每个小团队都应该以做产品的方式，对产品的整个生命周期负责</li></ul><h4 id="智能端点与哑管道">智能端点与哑管道</h4><ul><li><p>不再如同单体应用的组件直接通过函数调用进行交互协作</p></li><li><p>由于服务不再一个进程中，组件间的通信模式发生了改变</p></li><li><p>若仅仅是RPC的方式调用，会导致微服务之间繁琐的通信</p><p>更粗粒度的通信协议，微服务架构中，通常以这两种服务调用方式</p></li><li><p>使用HTTP的<code>RESTful API</code>或轻量级的消息发送协议，实现信息传递与服务调用的触发</p></li><li><p>通过再轻量级的消息总线上传递消息，类似RabbitMQ等一些提供可靠异步交换的中间件</p></li></ul><h4 id="去中心化治理">去中心化治理</h4><h4 id="去中心化管理数据">去中心化管理数据</h4><ul><li>将原数据库中的存储内容拆分到新的同平台的其他数据库实例中</li><li>将一些具有特殊结构或者业务特性的数据存储到一些其他技术的数据库实例中(如把日志信息存储到MongoDB中或者用户登录信息存储到Redis中)</li></ul><h4 id="基础设施自动化">基础设施自动化</h4><ul><li>自动化测试</li><li>自动化部署</li></ul><h4 id="容错设计">容错设计</h4><ul><li>部分服务出现故障，而其他服务仍可正常运行</li><li>但是设计时必须要考虑自动恢复服务，当故障蔓延的时候必须要快速检查出故障源</li><li>因此希望再每个服务中实现监控和日志记录的组件，比如服务状态、断路器状态、吞吐量、网络延迟等关键数据的仪表盘等</li></ul><h4 id="演进式设计">演进式设计</h4><ul><li>初期使用单体系统的方式来设计与实施</li><li>随着系统的发展或者业务的需要，将一些经常变动或者是有一定时间效应的内容进行微服务处理</li><li>逐渐将单体系统中多变的模块逐步拆分出来</li><li>而稳定不多变的模块就形成一个核心微服务</li></ul><h3 id="微服务架构初期">微服务架构初期</h3><p>在微服务架构初期，有一些需要解决的问题，下列是各个问题的一些开源解决方案</p><ul><li><p>服务治理</p><p>阿里巴巴开源的Dubbo和当当网在其基础上扩展的DubboX，Netfix的Eureka，Apache的Consul...</p></li><li><p>分布式配置管理</p><p>百度的Disconf，Netfix的Archaius，360的QConf，Spring Cloud的Config，淘宝的Diamond...</p></li><li><p>批量任务</p><p>当当网的Elastic-Job，LinkedIn的Azkaban，Spring Cloud的Task...</p></li><li><p>服务跟踪</p><p>京东的Hydra，Spring Cloud的Sleuth，Twitter的Zipkin</p></li></ul><h3 id="为什么选择spring-cloud">为什么选择Spring Cloud</h3><p>前面列举的框架，只是解决微服务中的某一个问题，而Spring Cloud则是一个解决微服务架构实施的综合性解决框架，在Spring社区的整合下，做了大量的兼容性测试，保证了其拥有更好的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之BitMap</title>
      <link href="/posts/1536016721/"/>
      <url>/posts/1536016721/</url>
      
        <content type="html"><![CDATA[<h3 id="redis的bitmap">Redis的BitMap</h3><h4 id="前言">前言</h4><ul><li>通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身</li><li>版本：redis 2.2.0</li><li>新增 setbit,getbit,bitcount几个bitmap相关命令</li></ul><h4 id="setbit命令说明">setbit命令说明</h4><p>指令 <code>setbit key offset value</code></p><ul><li>复杂度o(1)</li><li>设置或者清空key的取决于value(字符串)在offset处的bit值(只能只0或者1)</li><li>字符串会进行伸展(grown)以确保它可以将value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。</li><li>offset参数必须大于或等于0，小于2^32</li><li><strong>返回值</strong> 字符串值指定偏移量上原来存储的位（bit)</li></ul><h4 id="getbit命令说明">getbit命令说明</h4><p>指令<code>getbit key offest</code></p><ul><li>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。</li><li>当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code></li><li><strong>返回值</strong> 字符串指定偏移量上的位</li></ul><h4 id="bitcount命令说明">bitcount命令说明</h4><p>指令<code>bitcount key</code>、<code>bitcount key start end</code></p><ul><li>计算给定字符串中，被设置为1的比特位的数量</li><li>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行</li><li><code>start</code> 和 <code>end</code> 参数的设置和 <code>GETRANGE</code> 命令类似，都可以使用负数值： 比如 <code>-1</code> 表示最后一个字节， <code>-2</code>表示倒数第二个字节，以此类推</li><li>不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 0。</li><li><strong>返回值</strong> 被设置为1的位的数量</li></ul><h4 id="使用场景">使用场景</h4><h5 id="用户签到">1. 用户签到</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Jedis redis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.31.89"</span>,<span class="number">6379</span>,<span class="number">100000</span>);</span><br><span class="line"><span class="comment">//用户uid</span></span><br><span class="line">String uid = <span class="string">"1"</span>;</span><br><span class="line">String cacheKey = <span class="string">"sign_"</span>+Integer.valueOf(uid);</span><br><span class="line"><span class="comment">//记录有uid的key</span></span><br><span class="line"><span class="comment">// $cacheKey = sprintf("sign_%d", $uid);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始有签到功能的日期</span></span><br><span class="line">String startDate = <span class="string">"2017-01-01"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//今天的日期</span></span><br><span class="line">String todayDate = <span class="string">"2017-01-21"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算offset(时间戳)</span></span><br><span class="line"><span class="keyword">long</span> startTime = dateParase(startDate,<span class="string">"yyyy-MM-dd"</span>).getTime();</span><br><span class="line"><span class="keyword">long</span> todayTime = dateParase(todayDate,<span class="string">"yyyy-MM-dd"</span>).getTime();</span><br><span class="line"><span class="keyword">long</span> offset = (<span class="keyword">long</span>) Math.floor((todayTime - startTime) / <span class="number">86400</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"今天是第"</span>+offset+<span class="string">"天"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//签到</span></span><br><span class="line"><span class="comment">//一年一个用户会占用多少空间呢？大约365/8=45.625个字节，好小，有木有被惊呆？</span></span><br><span class="line">redis.setbit(cacheKey,offset,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询签到情况</span></span><br><span class="line"><span class="keyword">boolean</span> bitStatus = redis.getbit(cacheKey, offset);</span><br><span class="line"><span class="comment">//判断是否已经签到</span></span><br><span class="line"><span class="comment">//计算总签到次数</span></span><br><span class="line"><span class="keyword">long</span> qdCount = redis.bitcount(cacheKey);</span><br></pre></td></tr></table></figure><h5 id="统计活跃用户">2. 统计活跃用户</h5><p>使用时间作为cacheKey，然后用户ID为offset，如果当日活跃过就设置为1 那么我该如果计算某几天/月/年的活跃用户呢(暂且约定，统计时间内只有有一天在线就称为活跃)</p><p><strong>一个新的命令</strong> <code>BITOP operation destkey key [key ...]</code></p><p><strong>说明</strong> ：</p><ol type="1"><li>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上</li><li>BITOP 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,List&lt;Integer&gt;&gt;dateActiveuser = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Jedis redis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.31.89"</span>,<span class="number">6379</span>,<span class="number">100000</span>);</span><br><span class="line">Integer[] temp01 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">List&lt;Integer&gt;temp01List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(temp01List,temp01);</span><br><span class="line">dateActiveuser.put(<span class="string">"2017-01-10"</span>,temp01List);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer[] temp02 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">List&lt;Integer&gt;temp02List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(temp02List,temp02);</span><br><span class="line">dateActiveuser.put(<span class="string">"2017-01-11"</span>,temp02List);</span><br><span class="line"></span><br><span class="line">Integer[] temp03 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">List&lt;Integer&gt;temp03List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(temp03List,temp03);</span><br><span class="line">dateActiveuser.put(<span class="string">"2017-01-12"</span>,temp03List);</span><br><span class="line"></span><br><span class="line">Integer[] temp04 = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">List&lt;Integer&gt;temp04List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(temp04List,temp04);</span><br><span class="line">dateActiveuser.put(<span class="string">"2017-01-13"</span>,temp04List);</span><br><span class="line"></span><br><span class="line">Integer[] temp05 = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">List&lt;Integer&gt;temp05List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(temp05List,temp05);</span><br><span class="line">dateActiveuser.put(<span class="string">"2017-01-14"</span>,temp05List);</span><br><span class="line"></span><br><span class="line">String date[] = &#123;<span class="string">"2017-01-10"</span>,<span class="string">"2017-01-11"</span>,<span class="string">"2017-01-12"</span>,<span class="string">"2017-01-13"</span>,<span class="string">"2017-01-14"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试数据放入redis中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;date.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dateActiveuser.get(date[i]).size();j++)&#123;</span><br><span class="line">        redis.setbit(date[i], dateActiveuser.get(date[i]).get(j), <span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bitOp</span></span><br><span class="line">redis.bitop(BitOP.AND, <span class="string">"stat"</span>, <span class="string">"stat_2017-01-10"</span>, <span class="string">"stat_2017-01-11"</span>,<span class="string">"stat_2017-01-12"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"总活跃用户："</span>+redis.bitcount(<span class="string">"stat"</span>));</span><br><span class="line"></span><br><span class="line">redis.bitop(BitOP.AND, <span class="string">"stat1"</span>, <span class="string">"stat_2017-01-10"</span>, <span class="string">"stat_2017-01-11"</span>,<span class="string">"stat_2017-01-14"</span>);</span><br><span class="line">System.out.println(<span class="string">"总活跃用户："</span>+redis.bitcount(<span class="string">"stat1"</span>));</span><br><span class="line"></span><br><span class="line">redis.bitop(BitOP.AND, <span class="string">"stat2"</span>, <span class="string">"stat_2017-01-10"</span>, <span class="string">"stat_2017-01-11"</span>);</span><br><span class="line">System.out.println(<span class="string">"总活跃用户："</span>+redis.bitcount(<span class="string">"stat2"</span>));</span><br></pre></td></tr></table></figure><p>假设当前站点有5000W用户，那么一天的数据大约为50000000/8/1024/1024=6MB</p><h5 id="用户在线状态">3. 用户在线状态</h5><p>前段时间开发一个项目，对方给我提供了一个查询当前用户是否在线的接口。不了解对方是怎么做的，自己考虑了一下，使用bitmap是一个节约空间效率又高的一种方法，只需要一个key，然后用户ID为offset，如果在线就设置为1，不在线就设置为0，和上面的场景一样，5000W用户只需要6MB的空间。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量设置在线状态</span></span><br><span class="line">$uids = range(<span class="number">1</span>, <span class="number">500000</span>);</span><br><span class="line"><span class="keyword">foreach</span>($uids <span class="keyword">as</span> $uid) &#123;</span><br><span class="line">$redis-&gt;setBit(<span class="string">'online'</span>, $uid, $uid % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个一个获取状态</span></span><br><span class="line">$uids = range(<span class="number">1</span>, <span class="number">500000</span>);</span><br><span class="line">$startTime = microtime(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">foreach</span>($uids <span class="keyword">as</span> $uid) &#123;</span><br><span class="line"><span class="keyword">echo</span> $redis-&gt;getBit(<span class="string">'online'</span>, $uid) . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line">$endTime = microtime(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//在我的电脑上，获取50W个用户的状态需要25秒</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"total:"</span> . ($endTime - $startTime) . <span class="string">"s"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对于批量的获取，上面是一种效率低的办法，实际可以通过get获取到value，然后自己计算 </span></span><br><span class="line"><span class="comment">* 具体计算方法改天再写吧，之前写的代码找不见了。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报0316~0322</title>
      <link href="/posts/3903106024/"/>
      <url>/posts/3903106024/</url>
      
        <content type="html"><![CDATA[<h3 id="主要完成内容">主要完成内容</h3><ol type="1"><li>完成缅怀秦老先生献花点烛留言板的后端开发，并上线-&gt;<a href="http://mournqinhuali.njupt.edu.cn/mourn/" target="_blank" rel="noopener">传送门</a></li><li>完成电费/跑操预警推送后台人为控制，已上线</li><li>讨论并且敲定新注册方案，已进入测试阶段</li></ol><h3 id="踩坑总结">踩坑总结</h3><h4 id="项目war包部署">项目war包部署</h4><ol type="1"><li><p>打成war包要将springboot自带的tomcat排除掉</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用外部tomcat还需要继承<code>SpringBootServletInitializer</code>类，并且需要重写configure方法</p><p>如果不继承该类会怎么样呢？答：项目无法使用外部容器启动</p><p>如果重复继承会怎么样呢？答：项目可以启动，但是会遇到很多不可预期的问题</p><figure><img src="https://www.yunforum.net/uploadfile/editor/0/2/2808.png" alt><figcaption>img</figcaption></figure></li></ol><h4 id="nginx配置问题">nginx配置问题</h4><ul><li>root和alias的区别主要在于替换的部分，root模式中，会把root配置的路径替换匹配后的url中的host。alias则把他指定的路径，替换url中匹配的部分。指令中的斜杠对于root指令没有影响，对于alise则按照替换规则匹配即可。</li><li>通常最佳实际是配置一个项目的根root，其他的文件夹则使用alias，毕竟alias更加灵活。</li><li>修改配置文件之后要重启，<code>nginx -s reload</code></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /static &#123;</span><br><span class="line">    <span class="attribute">root</span> /vagrant/pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#计算路径/vagrant/pro + /static/stc.jpg</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /upload &#123;</span><br><span class="line">    <span class="attribute">alias</span> /vagrant/pro/upload;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#计算路径 /vagrant/pro/upload/ + /up.png</span></span><br></pre></td></tr></table></figure><ul><li>/对root指令无太大影响，而alias对斜杠的要求更高</li></ul><h4 id="springboot自带的async注解">SpringBoot自带的Async注解</h4><ul><li><span class="citation" data-cites="Async起作用必须在入口类上配置">@Async起作用必须在入口类上配置</span> <span class="citation" data-cites="EnableAsync开启异步处理">@EnableAsync开启异步处理</span></li><li>必须要新建一个类，类中写入task的方法，并加上注释</li><li>异步处理最好要自己定义线程池，此时@Async注解可以在括号中指定线程池的名称</li></ul><h3 id="下周计划">下周计划</h3><ol type="1"><li>开始学习一波SpringCloud，慢慢写个demo</li><li>落下了两周的课 先补回来 T_T</li><li>三道算法题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周报 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 踩坑 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
